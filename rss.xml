<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Kevin Stone</title><description>Personal blog for Kevin Stone.</description><link>https://blog.kevinastone.com/</link><item><title>Django Model Descriptors</title><link>https://blog.kevinastone.com/django-descriptors/</link><guid isPermaLink="true">https://blog.kevinastone.com/django-descriptors/</guid><description>How we can use Python Descriptors to create enhanced Django model fields that better encapsulate their functionality.  This will help keep our code more modular and reusable and well as cleaner and more maintainable.</description><pubDate>Wed, 26 Nov 2014 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;How can we enhance our Django model fields to act beyond simple database types
to encapsulate their associated business logic? Leveraging Python&apos;s
descriptor protocol, we provide additional processing on retrieval and update
to allow more re-usable fields.&lt;/p&gt;
&lt;h1&gt;Python Descriptors&lt;/h1&gt;
&lt;p&gt;What are &lt;a href=&quot;https://docs.python.org/2/howto/descriptor.html&quot;&gt;Python Descriptors&lt;/a&gt;? They&apos;re one of the least
understood aspects of the language, but I think of them like class-based
&lt;a href=&quot;https://docs.python.org/2/library/functions.html#property&quot;&gt;properties&lt;/a&gt;. Just as you can provide a &lt;code&gt;__call__&lt;/code&gt; method on a
class so that it acts like a function, you can supply a &lt;code&gt;__get__&lt;/code&gt; (or
&lt;code&gt;__set__&lt;/code&gt; or &lt;code&gt;__delete__&lt;/code&gt;) and the class will similarly act more like a
property.&lt;/p&gt;
&lt;p&gt;This allows us to capture common property definitions in a re-usable construct
that we can apply as generic functionality to our models. If you&apos;re read the
post on &lt;a href=&quot;/django-model-behaviors&quot;&gt;Django Model Behaviors&lt;/a&gt;, you understand how
to package common field definitions into a shared model behavior that you can
combine to assemble your models from more atomic functionality. Leveraging
descriptors, you can perform a similar deconstruction but this time by
creating re-usable fields with enhanced logic without being tied to a given
model definition.&lt;/p&gt;
&lt;h3&gt;Sample Code&lt;/h3&gt;
&lt;p&gt;All the sample code for this project is available on a &lt;a href=&quot;https://github.com/kevinastone/django-descriptors&quot;&gt;GitHub
repository&lt;/a&gt;. Feel free to use it as the basis for your own
experimentation.&lt;/p&gt;
&lt;h1&gt;Enhance your Models with Properties&lt;/h1&gt;
&lt;p&gt;A common use of properties is to perform calculations or manipulations on a
given field and provide that as additional information.&lt;/p&gt;
&lt;p&gt;For example, let&apos;s start with this Bookmark model that features a &lt;code&gt;url&lt;/code&gt; field:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.db import models


class Bookmark(models.Model):
    url = models.URLField()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&apos;s very simple and straightforward. Now let&apos;s say we want to extract some
additional information about the stored url, say it&apos;s domain/hostname so we
can show a favicon on our listing. Since the url already contains the
hostname, we can add a method or a property to our model which retrieves the
url, and then parses out the hostname.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import urlparse
from django.db import models


class Bookmark(models.Model):
    url = models.URLField()

    @property
    def hostname(self):
        return urlparse.urlparse(self.url).hostname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, when we&apos;re accessing our bookmark model instances, we can simple refer to
&lt;code&gt;obj.hostname&lt;/code&gt;. This pattern works great for many common derived or computed
values. No reason to store redundant information when we can calculate it on
the fly from other model attributes.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; boomark = Bookmark(url=&apos;http://example.com/abcd&apos;)

&amp;gt;&amp;gt;&amp;gt; # Let&apos;s access our hostname property
&amp;gt;&amp;gt;&amp;gt; bookmark.hostname
&apos;example.com`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But as we add more and more computed values, these properties tend to overload
our models, cluttering our codebase. Plus, we are frequently adding the same
properties again and again, repeating the same functionality for each field.
What we&apos;d like is a way to associate a given property with the model field
that derives it.&lt;/p&gt;
&lt;h1&gt;Descriptors as Reusable Properties&lt;/h1&gt;
&lt;p&gt;Rather than define a bunch of properties, what we&apos;d rather do is something
like: &lt;code&gt;obj.url.hostname&lt;/code&gt;, and encapsulate all the derived logic on the url
field. Yet when you access a model instance&apos;s field, it&apos;s simply returned
just like the original python type (str/unicode in the case of a &lt;em&gt;URLField&lt;/em&gt;).
These additional properties would be transparent to the rest of the code.&lt;/p&gt;
&lt;p&gt;So, we need to intercept the value returned by accessing the field on the
instance and &lt;strong&gt;enhance&lt;/strong&gt; it with our custom properties. This is where the
descriptor protocol comes into play. It gives us a chance to intercept and
substitute the value returned when an attribute is accessed on a given class
instance.&lt;/p&gt;
&lt;p&gt;To make this work, we actually need two components. First, we need our
descriptor which performs the intercept and substitution. Second, we need a
proxy model that acts like the original datatype, but is augmented with the
additional custom properties.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class URLFieldProxy(unicode):
    @property
    def hostname(self):
        return urlparse.urlparse(self).hostname


class ProxyFieldDescriptor(object):
    def __init__(self, field_name, proxy_class):
        self.field_name = field_name
        self.proxy_class = proxy_class

    def __get__(self, instance=None, owner=None):
        # grab the original value before we proxy
        value = instance.__dict__[self.field_name]
        if value is None:
            # We can&apos;t proxy a None through a unicode sub-class
            return value
        return self.proxy_class(value)

    def __set__(self, instance, value):
        instance.__dict__[self.field_name] = value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our &lt;em&gt;Proxy&lt;/em&gt; class, &lt;code&gt;URLFieldProxy&lt;/code&gt;, sub-classes the base type that the field
would return (&lt;code&gt;unicode&lt;/code&gt; in this case). That ensures we have the same base
datatype. And then it adds a property for calculating the derived value(s).&lt;/p&gt;
&lt;p&gt;Our &lt;em&gt;Descriptor&lt;/em&gt; class, &lt;code&gt;ProxyFieldDescriptor&lt;/code&gt;, is a regular python object,
with the magic methods &lt;code&gt;__get__&lt;/code&gt; and &lt;code&gt;__set__&lt;/code&gt; that define a descriptor. It
features a constructor that takes a two arguments, the name of the field we
want to intercept, and the proxy class we want to substitute. The &lt;code&gt;__get__&lt;/code&gt;
implementation looks up the original value of the intercepted field using
&lt;code&gt;instance.__dict__&lt;/code&gt; and then instantiates our proxy class passing in that
original value. We special case &lt;code&gt;None&lt;/code&gt; since our proxy can&apos;t handle that type
directly (&lt;em&gt;None&lt;/em&gt; values can&apos;t have properties). &lt;code&gt;__set__&lt;/code&gt; simply stores the
value directly without modification.&lt;/p&gt;
&lt;p&gt;Before we talk through how to attach this descriptor to your django model
field, let&apos;s put our implementation through some paces to show how a
descriptor operates.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SomeObject(object):
    # Let&apos;s add our descriptor on the `url` field substituting `URLFieldProxy`
    wormhole = ProxyFieldDescriptor(&apos;url&apos;, URLFieldProxy)

    def __init__(self, url):
        self.url = url
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember that we defined our descriptor to look up it&apos;s real value from the
passed in argument name. It then returns the &lt;em&gt;Proxy&lt;/em&gt; model that adds the
computed properties. Let&apos;s see it in action:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; obj = SomeObject(&apos;http://example.com/asdf&apos;)

&amp;gt;&amp;gt;&amp;gt; # Normal attribute access still works
&amp;gt;&amp;gt;&amp;gt; obj.url
&apos;http://example.com/asdf&apos;

&amp;gt;&amp;gt;&amp;gt; # Does obj.url have a hostname property?
&amp;gt;&amp;gt;&amp;gt; obj.url.hostname
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)

&amp;gt;&amp;gt;&amp;gt; # What about accessing our descriptor field?
&amp;gt;&amp;gt;&amp;gt; obj.wormhole
u&apos;http://example.com/asdf&apos;

&amp;gt;&amp;gt;&amp;gt; # Let&apos;s access the descriptor&apos;s property
&amp;gt;&amp;gt;&amp;gt; obj.wormhole.hostname
u&apos;example.com&apos;

# As you can see, the descriptor returns our proxy
&amp;gt;&amp;gt;&amp;gt; type(obj.wormhole)
__main__.URLFieldProxy

# But the proxy still *acts* like our original url attribute
&amp;gt;&amp;gt;&amp;gt; obj.wormhole == obj.url
True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Customize Django Model Fields with Descriptors&lt;/h2&gt;
&lt;p&gt;Now, we need to customize the Django &lt;code&gt;URLField&lt;/code&gt; to hook in to the descriptor
class. Thankfully, django provides an accessible mechanism under a method
named &lt;code&gt;contribute_to_class&lt;/code&gt; that allows you to customize how a field class is
attached to its model instance. The specifics of how this method works are
convoluted and related to the metaclass magic that django model definitions
perform.&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;contribute_to_class&lt;/code&gt; is used by django when building the model
instance, we simply attach our descriptor in the place of the field&apos;s name on
our constructed model instance using &lt;code&gt;setattr()&lt;/code&gt; with &lt;code&gt;self.name&lt;/code&gt; representing
the name of the field (&quot;url&quot; in our case).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class HostnamedURLField(models.URLField):
    def contribute_to_class(self, cls, name):
        super(HostnamedURLField, self).contribute_to_class(cls, name)
        # Add our descriptor to this field in place of of the normal attribute
        setattr(cls, self.name, ProxyFieldDescriptor(self.name, URLFieldProxy))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, let&apos;s update our model to use our customized url field. Notice our
model definition knows nothing about hostnames, it&apos;s all encapsulated in our
customized &lt;em&gt;URLField&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Bookmark(models.Model):
    url = HostnamedURLField()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the model all wired up with our descriptor wielding field, let&apos;s
see if it works.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; bookmark = Bookmark(url=&apos;http://example.com/asdf&apos;)

&amp;gt;&amp;gt;&amp;gt; bookmark.url
u&apos;http://example.com/asdf&apos;

&amp;gt;&amp;gt;&amp;gt; bookmark.url.hostname
u&apos;example.com&apos;

&amp;gt;&amp;gt;&amp;gt; # You can assign to the descriptor field too
&amp;gt;&amp;gt;&amp;gt; bookmark.url = u&apos;http://somewhere.com/else&apos;

&amp;gt;&amp;gt;&amp;gt; # And it still keeps all the same semantics
&amp;gt;&amp;gt;&amp;gt; bookmark.url.hostname
u&apos;somewhere.com&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There you go, we have a successfully migrated a computed property from the
model definition to the field definition. This helps keep common
functionality encapsulated, allowing greater re-use and cleaner separation of
concerns.&lt;/p&gt;
&lt;h1&gt;Descriptors for Alternative Representations&lt;/h1&gt;
&lt;p&gt;Besides just augmenting fields with computed properties, descriptors can also
be used to provide additional representations for your model data.&lt;/p&gt;
&lt;p&gt;One of my favorite database modeling patterns is to use timestamps for boolean
flags. If a timestamp is NULL, it&apos;s off (or disabled). When a timestamp is
set, the flag is enabled. This gives you both a status (on/off) as well as a
history of when the flag was enabled.&lt;/p&gt;
&lt;p&gt;In most uses, we&apos;re only concerned with the status, so a boolean data type is
more representative. But certain views would like to know this date
information (for say a management overview).&lt;/p&gt;
&lt;p&gt;Let&apos;s create another simple model to walk through such a use case:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.db import models


class BlogPost(models.Model):
    content = models.TextField()
    published_at = models.DateTimeField(null=True, default=None)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With a &lt;code&gt;published_at&lt;/code&gt; field, we can show visitors posts that have been marked
ready for publication, as well as sort our blog posts based on their
publication date. This same pattern works great for any moderation task,
including comments, account setup, or content release.&lt;/p&gt;
&lt;p&gt;With our model, we can create a few posts and then publish them by setting our
timestamp field to a non-NULL value.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.utils import timezone
&amp;gt;&amp;gt;&amp;gt; post = BlogPost.objects.create()
&amp;gt;&amp;gt;&amp;gt; post.published_at is not None
False
&amp;gt;&amp;gt;&amp;gt; BlogPost.objects.filter(published_at__isnull=False)
[]
&amp;gt;&amp;gt;&amp;gt; # Now let&apos;s set our published flag
&amp;gt;&amp;gt;&amp;gt; post.published_at = timezone.now()
&amp;gt;&amp;gt;&amp;gt; post.save()
&amp;gt;&amp;gt;&amp;gt; post.published_at is not None
True
&amp;gt;&amp;gt;&amp;gt; BlogPost.objects.filter(published_at__isnull=False)
[&amp;lt;BlogPost: BlogPost object&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Creating a Hybrid Boolean/Timestamp Descriptor&lt;/h2&gt;
&lt;p&gt;Using a datetime field gives us that extra information, but it makes working
with such fields less intuitive. You have to know it&apos;s a datetime value
rather than a boolean. What if we could use descriptors to modify the
returned field to act like a boolean?&lt;/p&gt;
&lt;p&gt;Let&apos;s create a descriptor class that proxies our datetime value, but acts like
a boolean.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class TimestampedBooleanDescriptor(object):
    def __init__(self, name):
        self.name = name

    def __get__(self, instance=None, owner=None):
        return instance.__dict__[self.name] is not None

    def __set__(self, instance, value):
        value = bool(value)
        if value != self.__get__(instance):
            if value:
                instance.__dict__[self.name] = timezone.now()
            else:
                instance.__dict__[self.name] = None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It handles two cases, the first is on &lt;code&gt;__get__&lt;/code&gt; where it checks its stored
timestamp against None. The other case is when &lt;code&gt;__set__&lt;/code&gt; is called, it checks
the input value (a boolean) and if it&apos;s changed, either sets or clears the
internal datetime representation.&lt;/p&gt;
&lt;p&gt;Let&apos;s build an example to use this descriptor.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class SomeObject(object):
    # Let&apos;s add our descriptor on the `timestamp` field
    boolean = TimestampedBooleanDescriptor(&apos;timestamp&apos;)

    def __init__(self, timestamp=None):
        self.timestamp = timestamp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And let&apos;s put our sample object through some paces:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; obj = SomeObject()
&amp;gt;&amp;gt;&amp;gt; obj.timestamp is None
True
&amp;gt;&amp;gt;&amp;gt; obj.boolean
False
&amp;gt;&amp;gt;&amp;gt; obj.timestamp = timezone.now()
&amp;gt;&amp;gt;&amp;gt; obj.boolean
True
&amp;gt;&amp;gt;&amp;gt; obj.boolean = False
&amp;gt;&amp;gt;&amp;gt; obj.timestamp is None
True
&amp;gt;&amp;gt;&amp;gt; obj.boolean = True
&amp;gt;&amp;gt;&amp;gt; obj.timestamp
datetime.datetime(2014, 12, 6, 21, 34, 12, 872457, tzinfo=&amp;lt;UTC&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Through the descriptor protocol, we were able to extend the functionality of
our fields to both support a datetime and a boolean interface.&lt;/p&gt;
&lt;p&gt;Now, let&apos;s extend the built-in &lt;code&gt;DateTimeField&lt;/code&gt; to use our descriptor class to
provide both interfaces. Our field adds two capabilities: first, we want to
add a second property on the given model for the boolean access (it defaults
to &lt;code&gt;is_&amp;lt;field_name&amp;gt;&lt;/code&gt;). Second, we again use &lt;code&gt;contribute_to_class&lt;/code&gt; to add our
additional boolean property on the model class.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class TimestampedBooleanField(models.DateTimeField):
    &quot;&quot;&quot;
    A Boolean field that also captures the timestamp when the value was set.

    This field stores a timestamp in the database when set.  It can be accessed
    as a boolean using the property argument (when not provided, it defaults to
    is_{field_name}).
    &quot;&quot;&quot;
    def __init__(self, *args, **kwargs):
        self.property_name = kwargs.pop(&apos;property&apos;, None)
        kwargs[&apos;null&apos;] = True
        super(TimestampedBooleanField, self).__init__(*args, **kwargs)

    def contribute_to_class(self, cls, name):
        super(TimestampedBooleanField, self).contribute_to_class(cls, name)
        # Use the defined boolean property name or pick a default
        property_name = self.property_name or &apos;is_{0}&apos;.format(name)
        setattr(cls, property_name, TimestampedBooleanDescriptor(self.name))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&apos;s now update our &lt;code&gt;BlogPost&lt;/code&gt; model to use this timestamp field.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class BlogPost(models.Model):
    content = models.TextField()
    published_at = TimestampedBooleanField(property=&apos;is_published&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the model all wired up with our descriptor wielding field, let&apos;s
see if it works.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; post = BlogPost()

&amp;gt;&amp;gt;&amp;gt; post.published_at is None
True

&amp;gt;&amp;gt;&amp;gt; post.is_published
False

&amp;gt;&amp;gt;&amp;gt; post.is_published = True
&amp;gt;&amp;gt;&amp;gt; post.published_at
datetime.datetime(2014, 12, 6, 21, 47, 17, 191879, tzinfo=&amp;lt;UTC&amp;gt;)

# Still works after reloading from the DB
&amp;gt;&amp;gt;&amp;gt; post.save()
&amp;gt;&amp;gt;&amp;gt; post2 = BlogPost.objects.get(pk=post.pk)
&amp;gt;&amp;gt;&amp;gt; post2.is_published
True
&amp;gt;&amp;gt;&amp;gt; post2.published_at
datetime.datetime(2014, 12, 6, 21, 47, 17, 191879, tzinfo=&amp;lt;UTC&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There you go, depending on how you want to access your model, you can choose
to use either the timestamp attribute or the boolean. All of this is
encapsulated in a descriptor class, keeping your model definition clean and
intuitive.&lt;/p&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;There&apos;s numerous opportunities to leverage descriptors to enhance your model
fields. Django itself uses them to handle File Upload fields since they&apos;re
stored in the database as pathnames to the file, but provided as a file-like
proxies to your django code.&lt;/p&gt;
&lt;p&gt;There&apos;s plenty of additional uses for descriptors. Please leave a comment (or
tweet, etc) if you have addditional ideas or examples where descriptors can
improve your model code.&lt;/p&gt;
</content:encoded></item><item><title>Django Model Behaviors</title><link>https://blog.kevinastone.com/django-model-behaviors/</link><guid isPermaLink="true">https://blog.kevinastone.com/django-model-behaviors/</guid><description>How do we manage the growing complexity of our Django models?  Leverage the behavior pattern to keep them compartmentalized into discrete reusable functionality.</description><pubDate>Sun, 12 May 2013 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;As Django projects scale in complexity beyond the neat and tidy tutorial phase, how can we structure our models to keep things manageable? We&apos;re talking 10s to 100s of models, used across numerous views, templates and tests...&lt;/p&gt;
&lt;h1&gt;Compositional Model Behaviors&lt;/h1&gt;
&lt;p&gt;The Compositional Model pattern allows you to manage the complexity of your models through compartmentalization of functionality into manageable components.&lt;/p&gt;
&lt;h3&gt;The Benefits of Fat Models&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Encapsulation&lt;/li&gt;
&lt;li&gt;Single Path&lt;/li&gt;
&lt;li&gt;Separation of Concerns (MVC)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Without the Maintenance Cost&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DRY&lt;/li&gt;
&lt;li&gt;Readability&lt;/li&gt;
&lt;li&gt;Reusability&lt;/li&gt;
&lt;li&gt;Single Responsibility Principle&lt;/li&gt;
&lt;li&gt;Testability&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Model Behaviors Example&lt;/h1&gt;
&lt;h3&gt;Traditional Model&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;class BlogPost(models.Model):
    title = models.CharField(max_length=255)
    body = models.TextField()
    slug = models.SlugField()
    author = models.ForeignKey(User, related_name=&apos;posts&apos;)
    create_date = models.DateTimeField(auto_now_add=True)
    modified_date = models.DateTimeField(auto_now=True)
    publish_date = models.DateTimeField(null=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Decomposed into Discrete Behaviors&lt;/h3&gt;
&lt;p&gt;The goal of the behavior pattern is to decompose your models into core, reusable mixins. Create a higher level abstraction than the model field that encapsulates the intended business logic.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from .behaviors import Authorable, Permalinkable, Timestampable, Publishable


class BlogPost(Authorable, Permalinkable, Timestampable, Publishable, models.Model):
    title = models.CharField(max_length=255)
    body = models.TextField()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Reusable Behaviors&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;class Authorable(models.Model):
    author = models.ForeignKey(User)

    class Meta:
        abstract = True


class Permalinkable(models.Model):
    slug = models.SlugField()

    class Meta:
        abstract = True


class Publishable(models.Model):
    publish_date = models.DateTimeField(null=True)

    class Meta:
        abstract = True


class Timestampable(models.Model):
    create_date = models.DateTimeField(auto_now_add=True)
    modified_date = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Models are more than just Fields&lt;/h1&gt;
&lt;p&gt;Our first cut at common behaviors just captured common fields, but what about everything else models encapsulate?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Properties&lt;/li&gt;
&lt;li&gt;Custom Methods&lt;/li&gt;
&lt;li&gt;Method Overloads (save(), etc...)&lt;/li&gt;
&lt;li&gt;Validation&lt;/li&gt;
&lt;li&gt;Querysets&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Capturing Model Methods&lt;/h3&gt;
&lt;p&gt;Let&apos;s extend our traditional fat model with some of these encapsulated busuiness logic&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class BlogPost(models.Model):
    ...

    @property
    def is_published(self):
        from django.utils import timezone
        return self.publish_date &amp;lt; timezone.now()

    @models.permalink
    def get_absolute_url(self):
        return (&apos;blog-post&apos;, (), {
            &quot;slug&quot;: self.slug,
        })

    def pre_save(self, instance, add):
        from django.utils.text import slugify
        if not instance.slug:
            instance.slug = slugify(self.title)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Behaviors with Methods&lt;/h3&gt;
&lt;p&gt;In actuality, these same methods can be generalized and extracted into our behavior models&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Permalinkable(models.Model):
    slug = models.SlugField()

    class Meta:
        abstract = True

    def get_url_kwargs(self, **kwargs):
        kwargs.update(getattr(self, &apos;url_kwargs&apos;, {}))
        return kwargs

    @models.permalink
    def get_absolute_url(self):
        url_kwargs = self.get_url_kwargs(slug=self.slug)
        return (self.url_name, (), url_kwargs)

    def pre_save(self, instance, add):
        from django.utils.text import slugify
        if not instance.slug:
            instance.slug = slugify(self.slug_source)


class Publishable(models.Model):
    publish_date = models.DateTimeField(null=True)

    class Meta:
        abstract = True

    objects = PassThroughManager.for_queryset_class(PublishableQuerySet)()

    def publish_on(self, date=None):
        from django.utils import timezone
        if not date:
            date = timezone.now()
        self.publish_date = date
        self.save()

    @property
    def is_published(self):
        from django.utils import timezone
        return self.publish_date &amp;lt; timezone.now()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Wire up the Concrete Model&lt;/h3&gt;
&lt;p&gt;Since we generalized our behaviors, we need to add some helpers on our concrete models to complete the functionality.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from .behaviors import Authorable, Permalinkable, Timestampable, Publishable


class BlogPost(Authorable, Permalinkable, Timestampable, Publishable, models.Model):
    title = models.CharField(max_length=255)
    body = models.TextField()

    url_name = &quot;blog-post&quot;

    @property
    def slug_source(self):
        return self.title
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Naming Tips&lt;/h1&gt;
&lt;p&gt;Use &quot;&amp;lt;verb&amp;gt;-able&quot; naming pattern for behaviors. The &quot;-able&quot; suffix ensures the behaviors are readily identifiable. It also prevents yet another use of the word Mixin. (Don&apos;t worry when the naming deviates from decent english such as in the case of &lt;code&gt;OptionallyGenericRelateable&lt;/code&gt;)&lt;/p&gt;
&lt;h1&gt;Custom Queryset Chaining&lt;/h1&gt;
&lt;p&gt;We all know to chain queryset methods, but what about adding custom manager methods?&lt;/p&gt;
&lt;p&gt;Let&apos;s Find Posts from a Given Author (username1) that are Published (publish_date in the past)&lt;/p&gt;
&lt;h3&gt;QuerySet without Encapsulation&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;from django.utils import timezone
from .models import BlogPost

&amp;gt;&amp;gt;&amp;gt; BlogPost.objects.filter(author__username=&apos;username1&apos;) \
.filter(publish_date__lte=timezone.now())
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Custom Managers&lt;/h3&gt;
&lt;p&gt;Let&apos;s create methods on a custom Manager to handle the past-publication date and author filters.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class BlogPostManager(models.Manager):

    def published(self):
        from django.utils import timezone
        return self.filter(publish_date__lte=timezone.now())

    def authored_by(self, author):
        return self.filter(author__username=author)


class BlogPost(models.Model):
    ...

    objects = BlogPostManager()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; published_posts = BlogPost.objects.published()
&amp;gt;&amp;gt;&amp;gt; posts_by_author = BlockPost.objects.authored_by(&apos;username1&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Chaining our Filters?&lt;/h3&gt;
&lt;p&gt;What if we try to chain our custom filters?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; BlogPost.objects.authored_by(&apos;username1&apos;).published()
AttributeError: &apos;QuerySet&apos; object has no attribute &apos;published&apos;

&amp;gt;&amp;gt;&amp;gt; type(Blogpost.objects.authored_by(&apos;username1&apos;))
&amp;lt;class &apos;django.db.models.query.QuerySet&apos;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;em&gt;Solution&lt;/em&gt;: Custom Querysets&lt;/h3&gt;
&lt;p&gt;Leverage &lt;code&gt;PassthroughManager&lt;/code&gt; from &lt;a href=&quot;https://github.com/carljm/django-model-utils&quot;&gt;django-model-utils&lt;/a&gt; to allow chaining of custom manager methods.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from model_utils.managers import PassThroughManager

class PublishableQuerySet(models.query.QuerySet):
    def published(self):
        from django.utils import timezone
        return self.filter(publish_date__lte=timezone.now())


class AuthorableQuerySet(models.query.QuerySet):
    def authored_by(self, author):
        return self.filter(author__username=author)

class BlogPostQuerySet(AuthorableQuerySet, PublishableQuerySet):
    pass


class BlogPost(Authorable, Permalinkable, Timestampable, Publishable, models.Model):
    ...

    objects = PassThroughManager.for_queryset_class(BlogPostQuerySet)()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you can chain custom methods inherited from multiple behaviors.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; author_public_posts = BlogPost.objects.authored_by(&apos;username1&apos;).published()

&amp;gt;&amp;gt;&amp;gt; type(Blogpost.objects.authored_by(&apos;username1&apos;))
&amp;lt;class &apos;example.queryset.BlogPostQuerySet&apos;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Ensulated Business Logic&lt;/h3&gt;
&lt;p&gt;What&apos;s more legible and maintainable?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BlogPost.objects.filter(author__username=&apos;username1&apos;).filter(publish_date__lte=timezone.now())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BlogPost.objects.authored_by(&apos;username1&apos;).published()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Testing Behaviors&lt;/h1&gt;
&lt;p&gt;Create matching Behavior tests to validate our models.&lt;/p&gt;
&lt;h3&gt;Same Benefits as for Models&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DRY&lt;/li&gt;
&lt;li&gt;Readability&lt;/li&gt;
&lt;li&gt;Reusability&lt;/li&gt;
&lt;li&gt;Single Responsibility&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Unit Test Example&lt;/h1&gt;
&lt;p&gt;We can create reusuable test components that validate our behaviors. The list of test mixins then become documentation for the expected role of the model.&lt;/p&gt;
&lt;h3&gt;Traditional Test&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;from django.test import TestCase

from .models import BlogPost


class BlogPostTestCase(TestCase):
    def test_published_blogpost(self):
        from django.utils import timezone
        blogpost = BlogPost.objects.create(publish_date=timezone.now())
        self.assertTrue(blogpost.is_published)
        self.assertIn(blogpost, BlogPost.objects.published())
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Converted to a Behavior Test Mixin&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;class BehaviorTestCaseMixin(object):
    def get_model(self):
            return getattr(self, &apos;model&apos;)

    def create_instance(self, **kwargs):
        raise NotImplementedError(&quot;Implement me&quot;)


class PublishableTests(BehaviorTestCaseMixin):
    def test_published_blogpost(self):
        from django.utils import timezone
        obj = self.create_instance(publish_date=timezone.now())
        self.assertTrue(obj.is_published)
        self.assertIn(obj, self.model.objects.published())
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;The Updated Unit Test&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;from django.test import TestCase

from .models import BlogPost
from .behaviors.tests import PublishableTests


class BlogPostTestCase(PublishableTests, TestCase):
    model = BlogPost

    def create_instance(self, **kwargs):
        return BlogPost.objects.create(**kwargs)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Combine with Model Specific Tests&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;class BlogPostTestCase(PublishableTests, AuthorableTests, PermalinkableTests, TimestampableTests, TestCase):
    model = BlogPost

    def create_instance(self, **kwargs):
        return BlogPost.objects.create(**kwargs)

    def test_blog_specific_functionality(self):
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Additional Model Testing Tips&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;a href=&quot;https://github.com/FactoryBoy/factory_boy&quot;&gt;Factory Boy&lt;/a&gt; for creating test instances/fixtures&lt;/li&gt;
&lt;li&gt;Use Inherited TestCases to validate different scenarios&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;class StaffBlogPostTestCase(PublishableTests, AuthorableTests, PermalinkableTests, TimestampableTests, BaseBlogPostTestCase):
    det setUp(self):
        self.user = StaffUser()

class AuthorizedUserBlogPostTestCase(PublishableTests, AuthorableTests, PermalinkableTests, TimestampableTests, BaseBlogPostTestCase):
    det setUp(self):
        self.user = AuthorizedUser()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Same behavior expected for Staff or Authorized User)&lt;/p&gt;
&lt;h1&gt;Reusability&lt;/h1&gt;
&lt;h3&gt;Eventually Build a Libray of Behaviors&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Permalinkable&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Publishable&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Authorable&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Timestampable&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Reusable both across our own Apps and shareable through the Community&lt;/h3&gt;
&lt;p&gt;More Examples&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Moderatable&lt;/em&gt; - &lt;code&gt;BooleanField(&apos;approved&apos;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Scheduleable&lt;/em&gt; - (&lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; with range queries)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;GenericRelatable&lt;/em&gt; (the triplet of &lt;code&gt;content_type&lt;/code&gt;, &lt;code&gt;object_id&lt;/code&gt; and &lt;code&gt;GenericForeignKey&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Orderable&lt;/em&gt; - &lt;code&gt;PositiveSmallIntegerField(&apos;position&apos;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Recommended App Layout&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;querysets.py&lt;/li&gt;
&lt;li&gt;behaviors.py (uses querysets)&lt;/li&gt;
&lt;li&gt;models.py (composition of querysets and behaviors)&lt;/li&gt;
&lt;li&gt;factories.py (uses models)&lt;/li&gt;
&lt;li&gt;tests.py (uses all, split this into a module for larger apps)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I usually have a &lt;em&gt;common&lt;/em&gt; app that has the shared behaviors, model and behavior test mixins with no dependencies on other apps.&lt;/p&gt;
&lt;h1&gt;Limitations/Pitfalls&lt;/h1&gt;
&lt;p&gt;Basically the challenges of Django Model Inheritance.&lt;/p&gt;
&lt;h3&gt;Leak Abstractions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Meta Options don&apos;t implicitly inherit (ordering, etc)&lt;/li&gt;
&lt;li&gt;Manager vs Queryset vs Model (some duplication of logic)&lt;/li&gt;
&lt;li&gt;ModelField options (toggling &lt;code&gt;default=True&lt;/code&gt; vs &lt;code&gt;default=False&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You often need to handle the composition yourself such as merging custom QuerySet classes or combining Meta Options.&lt;/p&gt;
&lt;h1&gt;3rd Party Helpers&lt;/h1&gt;
&lt;p&gt;Don&apos;t reinvent the wheel if you don&apos;t have to.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/django-extensions/django-extensions&quot;&gt;Django Extensions&lt;/a&gt; (UUIDField, AutoSlugField, etc)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/carljm/django-model-utils&quot;&gt;Django Model Utils&lt;/a&gt; (already mentioned)&lt;/li&gt;
&lt;li&gt;Filters (&lt;a href=&quot;https://github.com/alex/django-filter&quot;&gt;django-filter&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Test Helpers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Factories (&lt;a href=&quot;https://github.com/FactoryBoy/factory_boy&quot;&gt;factory boy&lt;/a&gt;)
Mocking (&lt;a href=&quot;http://www.voidspace.org.uk/python/mock/&quot;&gt;mock&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;All the example code from this post is available on a &lt;a href=&quot;https://github.com/kevinastone/django-model-behaviors-example&quot;&gt;GitHub Project&lt;/a&gt;.&lt;/p&gt;
</content:encoded></item><item><title>Generate Your Tests</title><link>https://blog.kevinastone.com/generator-tests/</link><guid isPermaLink="true">https://blog.kevinastone.com/generator-tests/</guid><pubDate>Mon, 12 Oct 2015 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;When testing your application, you&apos;ll often come across the need to test that
your application behaves correct across a range of inputs or conditions.
Instead of repetitively defining the same test scaffolding, let&apos;s use some
meta-programming to build our tests methods from a list of parameters.
&lt;a href=&quot;https://nose.readthedocs.org/en/latest/&quot;&gt;Nose&lt;/a&gt; has support for &lt;a href=&quot;https://nose.readthedocs.org/en/latest/writing_tests.html#test-generators&quot;&gt;Generator Tests&lt;/a&gt;, but they don&apos;t
work with python&apos;s &lt;code&gt;unittest&lt;/code&gt; framework. Let&apos;s walk-through how to build our
own test generator that does.&lt;/p&gt;
&lt;h1&gt;Our Test Case&lt;/h1&gt;
&lt;p&gt;So let&apos;s write a simple application for demonstration. We want to see if our
input string is alphabetized.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def is_alphabetized(value):
    return &apos;&apos;.join(sorted(value)) == value

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let&apos;s write a unit test case to check our implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import unittest

class IsAlphabetizedTestCase(unittest.TestCase):
    def test_is_alphabetized(self):
        self.assertTrue(is_alphabetized(&apos;abcd&apos;))

    def test_is_not_alphabetized(self):
        self.assertFalse(is_alphabetized(&apos;zyxw&apos;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can go ahead and run these tests and they should pass:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; nosetests example
..
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But as you can see, our two test methods only tested simple examples. What we
really want to test is our function over a wide range of inputs to ensure our
implementation is robust.&lt;/p&gt;
&lt;p&gt;At this point, your thought is usually to iterate over a range of cases in your method, and assert that each of them works as desired:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class IsAlphabetizedTestCase(unittest.TestCase):
    def test_is_alphabetized(self):
        inputs = [
            &apos;&apos;,
            &apos;a&apos;,
            &apos;aaaaa&apos;,
            &apos;ab&apos;,
            &apos;abcd&apos;,
        ]
        for input in inputs:
            self.assertTrue(is_alphabetized(input))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But you lose the benefit of having a single assertion in your test. You can&apos;t
isolate your test run to a single input. What if your test requires a setup
or teardown after each case? You can&apos;t use all the advantages of the test
framework.&lt;/p&gt;
&lt;p&gt;Let&apos;s say you have this setup and you get bug report that our naive
implementation above doesn&apos;t work correctly for &lt;code&gt;A-Cert&lt;/code&gt; as well as one for &lt;code&gt;iOS&lt;/code&gt;. Since we&apos;re big fans
of TDD, we&apos;ll plug that in our test case of expected inputs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from .alphabetical import is_alphabetized

import unittest


class IsAlphabetizedTestCase(unittest.TestCase):
    def test_is_alphabetized(self):
        inputs = [
            &apos;&apos;,
            &apos;a&apos;,
            &apos;aaaaa&apos;,
            &apos;ab&apos;,
            &apos;abcd&apos;,
            &apos;A-Cert&apos;,
            &apos;iOS&apos;,
        ]
        for input in inputs:
            self.assertTrue(is_alphabetized(input))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And give it a run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;======================================================================
FAIL: test_is_alphabetized (example.test_alphabetical.IsAlphabetizedTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;example/test_alphabetical.py&quot;, line 34, in test_is_alphabetized
    self.assertTrue(is_alphabetized(input))
AssertionError: False is not true

----------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But as you can see, we don&apos;t know which test failed. We should update our
test case to indicate which word failed:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    def test_is_alphabetized(self):
        inputs = [
            &apos;&apos;,
            &apos;a&apos;,
            &apos;aaaaa&apos;,
            &apos;ab&apos;,
            &apos;abcd&apos;,
            &apos;A-Cert&apos;,
            &apos;iOS&apos;,
        ]
        for input in inputs:
            self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;======================================================================
FAIL: test_is_alphabetized (example.test_alphabetical.IsAlphabetizedTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;example/test_alphabetical.py&quot;, line 46, in test_is_alphabetized
    self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))
AssertionError: A-Cert was not considered alphabetized

----------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we at least know which word failed. But what about &lt;code&gt;iOS&lt;/code&gt;? Because the
test exits on the first failure, we&apos;re unsure if that bug report was valid or
not.&lt;/p&gt;
&lt;p&gt;Before we go fixing our &lt;code&gt;is_alphabetical&lt;/code&gt; implementation to handle the
punctuation and capitalization, let&apos;s figure out how to get both inputs to
fail.&lt;/p&gt;
&lt;p&gt;Instead of looping in our test method, we could instead write separate test methods for each input:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class IsAlphabetizedTestCase(unittest.TestCase):

    def test_is_alphabetized_empty(self):
        self.assertTrue(is_alphabetized(&apos;&apos;))

    def test_is_alphabetized_a(self):
        self.assertTrue(is_alphabetized(&apos;a&apos;))

    def test_is_alphabetized_aaaaa(self):
        self.assertTrue(is_alphabetized(&apos;aaaaa&apos;))

    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But boy is that exhausting having to repeat ourselves for each test. Instead,
we&apos;d like to provide the list of inputs as before, but have individual test
methods generated for us. Nose actually supports this out of the box with
&lt;a href=&quot;https://nose.readthedocs.org/en/latest/writing_tests.html#test-generators&quot;&gt;Generator Tests&lt;/a&gt;, but you can&apos;t use them with python
&lt;code&gt;unittest.TestCase&lt;/code&gt; and we&apos;d lose any of help we get using the framework.&lt;/p&gt;
&lt;p&gt;But we can work around that limitation. We just need to define a new test
method on our test class for each input and nose will run them just like any
other test method.&lt;/p&gt;
&lt;p&gt;What we need to do is transform that list of inputs into individual test
methods. Instead of us manually writing all those test methods, what if we
wrote a function that wrote the test class for us?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class IsAlphabetizedTestCase(unittest.TestCase):
    pass


def add_methods(klass, *inputs):
    &quot;&quot;&quot;
    Take a TestCase and add a test method for each input
    &quot;&quot;&quot;
    for input in inputs:
        def test_input(self):
            self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))

        klass.test_input = test_input


add_methods(
    IsAlphabetizedTestCase,
    &apos;&apos;,
    &apos;a&apos;,
    &apos;aaaaa&apos;,
    &apos;ab&apos;,
    &apos;abcd&apos;,
    &apos;A-Cert&apos;,
    &apos;iOS&apos;,
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running those tests, we see:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;======================================================================
FAIL: test_input (example.test_alphabetical.IsAlphabetizedTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;example/test_alphabetical.py&quot;, line 16, in test_input
    self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))
AssertionError: iOS was not considered alphabetized

----------------------------------------------------------------------
Ran 2 tests in 0.001s

FAILED (errors=1, failures=1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What happened? Shouldn&apos;t there be more tests? Well, we kept clobbering our
test in the klass. The trick is to give each test a unique name.&lt;/p&gt;
&lt;p&gt;Let&apos;s assign the test to the class using &lt;code&gt;setattr&lt;/code&gt; with a custom name:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def add_methods(klass, *inputs):
    &quot;&quot;&quot;
    Take a TestCase and add a test method for each input
    &quot;&quot;&quot;
    for input in inputs:
        test_name = &apos;test_alphabetical_{}&apos;.format(input)

        def test_input(self):
            self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))

        setattr(klass, test_name, test_input)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now running the tests:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;======================================================================
FAIL: test_alphabetical_ (example.test_alphabetical.IsAlphabetizedTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;example/test_alphabetical.py&quot;, line 18, in test_input
    self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))
AssertionError: iOS was not considered alphabetized

======================================================================
FAIL: test_alphabetical_A-Cert (example.test_alphabetical.IsAlphabetizedTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;example/test_alphabetical.py&quot;, line 18, in test_input
    self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))
AssertionError: iOS was not considered alphabetized

[...]

----------------------------------------------------------------------
Ran 7 tests in 0.001s

FAILED (failures=7)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Why are all tests failing with &lt;code&gt;iOS&lt;/code&gt;? It should be running with each variant
of our input. Turns out this is due to variable scoping in python. In
python2, there&apos;s only two levels of scoping: function and global. So as we
loop and define &lt;code&gt;test_input&lt;/code&gt;, the value of &lt;code&gt;input&lt;/code&gt; is being updated. When our
test methods are actually evaluated, it&apos;s always equal to the last value
(&lt;code&gt;iOS&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;To fix that, we&apos;ll define yet another function to capture the value of input
(remember there&apos;s function scoping):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def make_method(input):
    test_name = &apos;test_alphabetical_{}&apos;.format(input)

    def test_input(self):
        self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))

    return test_name, test_input


def add_methods(klass, *inputs):
    &quot;&quot;&quot;
    Take a TestCase and add a test method for each input
    &quot;&quot;&quot;
    for input in inputs:
        test_name, test_input = make_method(input)
        setattr(klass, test_name, test_input)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With these changes, we finally get the results we expected:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;======================================================================
FAIL: test_alphabetical_A-Cert (example.test_alphabetical.IsAlphabetizedTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;example/test_alphabetical.py&quot;, line 14, in test_input
    self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))
AssertionError: A-Cert was not considered alphabetized

======================================================================
FAIL: test_alphabetical_iOS (example.test_alphabetical.IsAlphabetizedTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;example/test_alphabetical.py&quot;, line 14, in test_input
    self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))
AssertionError: iOS was not considered alphabetized

----------------------------------------------------------------------
Ran 7 tests in 0.001s

FAILED (failures=2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There you go, we are able to generate N test methods to validate our
alphabetical function. Adding a new test is as simple as extending the list
of inputs.&lt;/p&gt;
&lt;h1&gt;Improving the Test Generation&lt;/h1&gt;
&lt;p&gt;So we now have the ability to generate tests from an input list, but it
involves a few methods and our test is now deeply nested in a helper factory.
Let&apos;s improve this so we can use this more universally.&lt;/p&gt;
&lt;p&gt;First thing to notice is that &lt;code&gt;add_methods&lt;/code&gt; takes a class as the first
argument. That looks awfully like a decorator. Let&apos;s make a few tweaks so we
can use it to decorate our test class:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def add_methods(*inputs):
    &quot;&quot;&quot;
    Take a TestCase and add a test method for each input
    &quot;&quot;&quot;
    def decorator(klass):
        for input in inputs:
            test_name, test_input = make_method(input)
            setattr(klass, test_name, test_input)
        return klass

    return decorator


@add_methods(&apos;&apos;, &apos;a&apos;, &apos;aaaaa&apos;, &apos;ab&apos;, &apos;abcd&apos;, &apos;A-Cert&apos;, &apos;iOS&apos;)
class IsAlphabetizedTestCase(unittest.TestCase):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All we did was wrap our method generation in a &lt;code&gt;decorator&lt;/code&gt; function that takes
an input class, adds the method and returns the class.&lt;/p&gt;
&lt;h2&gt;Naming the Test Functions&lt;/h2&gt;
&lt;p&gt;if you inspect the test class, even though we have methods under unique names
based on the input (like &lt;code&gt;test_input_iOS&lt;/code&gt;), we can&apos;t reference those class
names when using nose because they all are still just named &lt;code&gt;test_input&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ipdb&amp;gt; pp IsAlphabetizedTestCase.test_alphabetical_iOS
&amp;lt;unbound method IsAlphabetizedTestCase.test_input&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix this, we need to set the &lt;code&gt;__name__&lt;/code&gt; attribute on the function when
generating it. This has the extra benefit of not needing to return a name for
the assignment, we can just use the same:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def make_method(input):
    def test_input(self):
        self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))

    test_input.__name__ = &apos;test_alphabetical_{}&apos;.format(input)
    return test_input


def add_methods(*inputs):
    &quot;&quot;&quot;
    Take a TestCase and add a test method for each input
    &quot;&quot;&quot;
    def decorator(klass):
        for input in inputs:
            test_input = make_method(input)
            setattr(klass, test_input.__name__, test_input)
        return klass

    return decorator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now with the function named accurately, we can specify a single test method to run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nosetests example/test_alphabetical.py:IsAlphabetizedTestCase.test_alphabetical_iOS
F
======================================================================
FAIL: test_alphabetical_iOS (example.test_alphabetical.IsAlphabetizedTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;example/test_alphabetical.py&quot;, line 8, in test_input
    self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))
AssertionError: iOS was not considered alphabetized

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Generalize the Test Method Factory&lt;/h1&gt;
&lt;p&gt;So our class decorator works well for our single test method generator. But
what if we have multiple test methods we want to generate? Remember our
initial example also included expected False results? Let&apos;s make it so we can
pass in the test method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from .alphabetical import is_alphabetized

import unittest


def assert_is_alphabetized(self, input):
    self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))


def assert_is_not_alphabetized(self, input):
    self.assertFalse(is_alphabetized(input), u&apos;{} was considered alphabetized&apos;.format(input))


def make_method(func, input):

    def test_input(self):
        func(self, input)

    test_input.__name__ = &apos;test_{func}_{input}&apos;.format(func=func.__name__, input=input)
    return test_input


def generate(func, *inputs):
    &quot;&quot;&quot;
    Take a TestCase and add a test method for each input
    &quot;&quot;&quot;
    def decorator(klass):
        for input in inputs:
            test_input = make_method(func, input)
            setattr(klass, test_input.__name__, test_input)
        return klass

    return decorator


@generate(assert_is_alphabetized, &apos;&apos;, &apos;a&apos;, &apos;aaaaa&apos;, &apos;ab&apos;, &apos;abcd&apos;, &apos;A-Cert&apos;, &apos;iOS&apos;)
@generate(assert_is_not_alphabetized, &apos;ba&apos;, &apos;aba&apos;, &apos;bob&apos;)
class IsAlphabetizedTestCase(unittest.TestCase):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can run all&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;======================================================================
FAIL: test_assert_is_alphabetized_A-Cert (example.test_alphabetical.IsAlphabetizedTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;example/test_alphabetical.py&quot;, line 17, in test_input
    func(self, input)
  File &quot;example/test_alphabetical.py&quot;, line 7, in assert_is_alphabetized
    self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))
AssertionError: A-Cert was not considered alphabetized

======================================================================
FAIL: test_assert_is_alphabetized_iOS (example.test_alphabetical.IsAlphabetizedTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;example/test_alphabetical.py&quot;, line 17, in test_input
    func(self, input)
  File &quot;example/test_alphabetical.py&quot;, line 7, in assert_is_alphabetized
    self.assertTrue(is_alphabetized(input), u&apos;{} was not considered alphabetized&apos;.format(input))
AssertionError: iOS was not considered alphabetized

----------------------------------------------------------------------
Ran 10 tests in 0.001s

FAILED (failures=2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Now with these handy generated test methods, we can make the necessary fixes
to our &lt;code&gt;is_alphabetical&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import re

def is_alphabetized(value):
    value = value.lower()
    value = re.sub(r&apos;[^a-z]&apos;, &apos;&apos;, value)
    return &apos;&apos;.join(sorted(value)) == value

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;----------------------------------------------------------------------
Ran 10 tests in 0.001s

OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ah, so satisfying....&lt;/p&gt;
</content:encoded></item><item><title>Batteries Included Django</title><link>https://blog.kevinastone.com/batteries-included-django/</link><guid isPermaLink="true">https://blog.kevinastone.com/batteries-included-django/</guid><description>A key benefit to using Python and/or Django for your next project, is the wealth of high quality 3rd party libraries that can help accelerate your development.  Python has a rich ecosystem of 3rd party libraries including often offical bindings for an external service.  This offers you significant tools to building rich, complex systems based on the available open source solutions.  Django&apos;s popularity and architecture provides the opportuntiy to find many existing solutions to common problems.  For education and discussion, I thought it would be helpful to enumerate the many libraries we currently use on Subblime to leverage the power of of the Python/Django ecosystem.  A what&apos;s in our toolbox sort of post.</description><pubDate>Tue, 16 Jul 2013 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;A key benefit to using Python and/or Django for your next project, is the wealth of high quality 3rd party libraries that can help accelerate your development. Python has a rich ecosystem of 3rd party libraries including often offical bindings for an external service. This offers you significant tools to building rich, complex systems based on the available open source solutions. Django&apos;s popularity and architecture provides the opportuntiy to find many existing solutions to common problems.&lt;/p&gt;
&lt;p&gt;For education and discussion, I thought it would be helpful to enumerate the many libraries we currently use on &lt;a href=&quot;http://subblime.com&quot;&gt;Subblime&lt;/a&gt; to leverage the power of of the Python/Django ecosystem. A what&apos;s in our toolbox sort of post.&lt;/p&gt;
&lt;h2&gt;Requirements.txt&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;distribute&amp;gt;=0.6.28
mysql-python&amp;gt;=1.2.4
Django&amp;gt;=1.5.4
pillow
Werkzeug
south&amp;gt;=0.8,&amp;lt;2.0
sorl-thumbnail
hamlpy
requests&amp;gt;=1.0
djangorestframework&amp;gt;=2.3.4
djangorestframework-csv
unicodecsv
# pynliner
# # Use our fork that leverages lxml, tinycss and cssselect
https://github.com/subblime/pynliner/tarball/master#egg=pynliner
cssutils

# Django Enhancements
django-extensions&amp;gt;1.2.1	# 1.2.0 included a unicode bug (see https://github.com/django-extensions/django-extensions/pull/366)
django-model-utils
django-templated-email
django-grappelli&amp;gt;=2.4.5
django-floppyforms
django-filter&amp;gt;=0.7
django-braces
django-autoslug

# Datetime
pytz&amp;gt;=2013d
iso8601
python-dateutil&amp;gt;=1.5,&amp;lt;2.0	# 2.1 includes breaking changes

# Deployment
uwsgi
fabric

# Caching
redis
hiredis
django-redis-cache
# johnny-cache
# Patch to skip caching ORDER BY RAND() queries
https://github.com/subblime/johnny-cache/tarball/master#egg=johnny-cache

# Django Compressor
django-compressor&amp;gt;=1.3	# Need recent django-compressor for precompile filter support
lxml
BeautifulSoup&amp;lt;4.0
cssselect
cssmin
tinycss
slimit
django-sekizai

# Celery
django-celery-with-redis	# includes celery and django-celery
flower
django-celery-transactions

# YouTube
gdata
google-api-python-client
oauth2client
django-social-auth&amp;gt;=0.7.22	# v0.7.22 removed social_auth.signals.pre_update which we now support through pipeline stages

# Social
facepy
twitter

# Mixpanel
# v0.6 introduced Celery 3.0 support
mixpanel-celery&amp;gt;=0.6.0

# For Sentry
raven&amp;gt;=3.0

# Lettuce
# Need version of Lettuce that supports proper Background sections including xunit support
lettuce&amp;gt;=0.2.18

# Charting
numpy
pandas&amp;gt;=0.12
sqlalchemy

# Search
django-haystack
pyelasticsearch
celery-haystack
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Testing Requirements.txt&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;factory_boy&amp;gt;=1.3,&amp;lt;2.0	# Guard against potential 2.0 breaking changes
mock
#pytimecop

# Nose
nose&amp;lt;1.3	# Nose 1.3 breaks our test discovery somehow
django-nose
coverage
nose-exclude
nose-progressive&amp;gt;=1.4.1
nosexcover
yanc
xtraceback

# Validaiton
pep8
flake8
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Lettuce Requirements.txt&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# Make sure you have Chromium installed (or appropriate for your dev platform)
splinter&amp;gt;=0.5    # Need 0.5 for PhantomJS support
selenium&amp;gt;=2.28	# Need 2.28 for PhantomJS support
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Basic Includes for Every Project&lt;/h1&gt;
&lt;p&gt;These are requirements I type before I even start a project. You&apos;re just likely to need them with some part of your problem set.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/python-imaging/Pillow&quot;&gt;Pillow&lt;/a&gt; (Image Manipulation)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/sorl/sorl-thumbnail&quot;&gt;sorl-thumbnail&lt;/a&gt; (Thumbnail Generation)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://south.aeracode.org&quot;&gt;South&lt;/a&gt; (DB Migrations)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python-requests.org&quot;&gt;Requests&lt;/a&gt; (HTTP client)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://django-rest-framework.org&quot;&gt;Django-Rest-Framework&lt;/a&gt; (ReST API endpoint)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DateTime Fixes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://pytz.sourceforge.net&quot;&gt;pytz&lt;/a&gt; (Timezone support)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bitbucket.org/micktwomey/pyiso8601&quot;&gt;iso8601&lt;/a&gt; (date formatting and parsing)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://labix.org/python-dateutil&quot;&gt;dateutil&lt;/a&gt; (parsing and translation)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You always end up exporting importing to CSV&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jdunck/python-unicodecsv&quot;&gt;unicodecsv&lt;/a&gt; (Fixes encoding for CSV import/export)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;General Django Helpers&lt;/h2&gt;
&lt;p&gt;Some utility knife style general enhancements to Django&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/django-extensions/django-extensions&quot;&gt;django-extensions&lt;/a&gt; - runserver_plus + shell_plus management commands (Werkzeug Debugger) - Useful generic model fields (CreationDateTimeField, etc)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/carljm/django-model-utils&quot;&gt;django-model-utils&lt;/a&gt; - Improved Querysets (PassThroughManager, InheritanceManager)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/brack3t/django-braces&quot;&gt;django-braces&lt;/a&gt; - CBV Mixins (instead of ugly decorators)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Django CRUD Helpers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/alex/django-filter&quot;&gt;django-filter&lt;/a&gt; - Don&apos;t write your own query string parameterizations until you&apos;ve tried django-filter&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/brutasse/django-floppyforms&quot;&gt;django-floppyforms&lt;/a&gt; - Better templates for django forms - import floppyforms as forms&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Admin Tools&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.grappelliproject.com&quot;&gt;django-grappelli&lt;/a&gt; (nicer skin)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/django-extensions/django-extensions&quot;&gt;django-extensions&lt;/a&gt; (again) - ForeignKeyAutocompleteAdmin makes admin useable for relations (search field instead of dropdown)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Batch Processing&lt;/h1&gt;
&lt;h3&gt;Celery&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://celeryproject.org&quot;&gt;django-celery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chrisdoble/django-celery-transactions&quot;&gt;django-celery-transactions&lt;/a&gt; - Delays task delivery until transactions commit to eliminate race conditions&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Email&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/bradwhittington/django-templated-email&quot;&gt;django-templated-email&lt;/a&gt; - Template support for mail subjects, and HTML + Plain versions&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rennat/pynliner&quot;&gt;pynliner&lt;/a&gt; - inline your CSS for to re-use your css in mail templates&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Cleaner Frontend Code&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jessemiller/HamlPy&quot;&gt;HamlPy&lt;/a&gt; (Template loader) - More readable and concise html generation - (Also more version control friendly since it&apos;s line based)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jezdez/django_compressor&quot;&gt;Django Compressor&lt;/a&gt; - Supports LessCSS and Coffeescript - lxml, BeautifulSoup, cssmin, slimit for minification - NPM Packages: less, jshint, recess, uglify-js, coffee-script&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ojii/django-sekizai&quot;&gt;django-sekizai&lt;/a&gt; - Adding resources in template fragments on demand&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Haml Templates&lt;/h3&gt;
&lt;p&gt;Regular Django HTML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;A bunch of placeholder text about your company.&amp;lt;/p&amp;gt;
&amp;lt;div class=&quot;actions&quot;&amp;gt;
    &amp;lt;div class=&quot;action-container pull-left&quot;&amp;gt;
        &amp;lt;a class=&quot;flat-button block-level call-to-action&quot; href=&quot;{% url &quot;join&quot; %}&quot;&amp;gt;Join our Site!&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;action-container pull-right&quot;&amp;gt;
        &amp;lt;a class=&quot;flat-button block-level call-to-action&quot; href=&quot;{% url &quot;login&quot; %}&quot;&amp;gt;Sign In&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Updated for Haml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%p
    A bunch of placeholder text about your company.
.actions
    .action-container.pull-left
        %a.flat-button.block-level.call-to-action{&apos;href&apos;: &apos;{% url &quot;join&quot; %}&apos;}
            Join our Site!
    .action-container.pull-right
        %a.flat-button.block-level.call-to-action{&apos;href&apos;: &apos;{% url &quot;login&quot; %}&apos;}
            Sign In
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Another Example&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;product-information-container&quot;&amp;gt;
    &amp;lt;div class=&quot;product-information&quot;&amp;gt;
        &amp;lt;h4&amp;gt;
            {% if headline %}{{ headline }}{% endif %}
            {% if url %}
            &amp;lt;p&amp;gt;
                &amp;lt;p&amp;gt;
                    &amp;lt;a href=&quot;{{ url }}&quot;&amp;gt;{{ url|format_url }}&amp;lt;/a&amp;gt;
                &amp;lt;/p&amp;gt;
            &amp;lt;/p&amp;gt;
            {% endif %}
        &amp;lt;/h4&amp;gt;
        {% if description %}
        &amp;lt;p class=&quot;description&quot;&amp;gt;{{ description }}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.product-information-container
    .product-information
        %h4
            - if headline
                = headline
            - if url
                %p
                    %a{&apos;href&apos;: &apos;={url}&apos;}
                        = url|format_url
        - if description
            %p.description&amp;lt;
                = description
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Django Sekizai&lt;/h3&gt;
&lt;p&gt;Sekizai allows you to specify assets (css, js) anywhere in your templates and capture them to include in the base template.&lt;/p&gt;
&lt;p&gt;In Your Base Template:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{% render_block &quot;js&quot; %}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or with Django Compressor Processors (say for Coffeescript)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{% render_block &quot;js&quot; postprocessor &quot;compressor.contrib.sekizai.compress&quot; %}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Included Fragment Example&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- addtoblock &quot;js&quot;
    %script{&apos;type&apos;: &apos;text/javascript&apos;, &apos;src&apos;: &apos;{% static &quot;js/jquery/jquery.timeago.js&quot; %}&apos;}
- endaddtoblock &quot;js&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Included Fragment Example (Coffeescript)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{% addtoblock &quot;js&quot; %}
    &amp;lt;script type=&quot;text/coffeescript&quot; src=&quot;{% static &quot;js/directives/date.coffee&quot; %}&quot;&amp;gt;&amp;lt;/script&amp;gt;
{% endaddtoblock &quot;js&quot; %}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Backend Services&lt;/h1&gt;
&lt;h2&gt;Algorithmic/Data Science&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.numpy.org&quot;&gt;NumPy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pandas.pydata.org&quot;&gt;Pandas&lt;/a&gt; - Powerful data transformations (esp. for time series data)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Other Useful Libs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.scipy.org&quot;&gt;SciPy&lt;/a&gt; - Algorithms galore&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nltk.org&quot;&gt;NLTK&lt;/a&gt; (language processing + statistics primitives)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pymc-devs/pymc&quot;&gt;PyMC&lt;/a&gt; (Bayesian inference)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Caching&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/andymccurdy/redis-py&quot;&gt;redis-py&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/pietern/hiredis-py&quot;&gt;hiredis-py&lt;/a&gt; (faster bindings for redis)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sebleier/django-redis-cache&quot;&gt;django-redis-cache&lt;/a&gt; (cache backend using redis)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;johnny-cache (transparent queryset caching)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;APIs and Authentication&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/omab/django-social-auth&quot;&gt;django-social-auth&lt;/a&gt; (oauth consumers) - now &lt;a href=&quot;https://github.com/omab/python-social-auth&quot;&gt;python-social-auth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Google - &lt;a href=&quot;https://developers.google.com/api-client-library/python/&quot;&gt;oauth2client&lt;/a&gt; - &lt;a href=&quot;https://code.google.com/p/google-api-python-client/&quot;&gt;google-api-python-client&lt;/a&gt; - &lt;a href=&quot;https://code.google.com/p/gdata-python-client/&quot;&gt;gdata&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Facebook - &lt;a href=&quot;https://github.com/jgorset/facepy&quot;&gt;facepy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Tracking/Reporting&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/winhamwr/mixpanel-celery&quot;&gt;mixpanel-celery&lt;/a&gt; (background mixpanel tracking)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/getsentry/raven-python&quot;&gt;raven&lt;/a&gt; (for Sentry)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Deployment and Testing&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://fabfile.org/&quot;&gt;Fabric&lt;/a&gt; (automation)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://projects.unbit.it/uwsgi&quot;&gt;uWSGi&lt;/a&gt; (WSGi container)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://werkzeug.pocoo.org&quot;&gt;Werkzeug&lt;/a&gt; (Lightweight WSGi framework)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Testing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/FactoryBoy/factory_boy&quot;&gt;Factory-boy&lt;/a&gt; (Fixtures)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.voidspace.org.uk/python/mock/&quot;&gt;mock&lt;/a&gt; (Mocking and Stubbing)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Feature Tests&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://lettuce.it&quot;&gt;lettuce&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/baijum/selenium-python&quot;&gt;selenium&lt;/a&gt; (web browser automation)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://splinter.cobrateam.info&quot;&gt;splinter&lt;/a&gt; (selenium wrapper)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Validation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jcrocholl/pep8&quot;&gt;pep8&lt;/a&gt; (coding standards)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://flake8.readthedocs.org/en/latest/&quot;&gt;flake8&lt;/a&gt; (static analysis based on PyFlakes)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Nose Plugins&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/nose-devs/nose&quot;&gt;nose&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jbalogh/django-nose&quot;&gt;django-nose&lt;/a&gt; - Nose based Test Runner for Django&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nedbatchelder.com/code/coverage/&quot;&gt;coverage&lt;/a&gt; - Code Coverage&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bitbucket.org/kgrandis/nose-exclude&quot;&gt;nose-exclude&lt;/a&gt; - Adds --exclude-dir= flags to skip certain dirs&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/erikrose/nose-progressive&quot;&gt;nose-progressive&lt;/a&gt; - Progress bar for test runner&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cmheisel/nose-xcover&quot;&gt;nosexcover&lt;/a&gt; (worst package name ever) - Code coverage for xunit results (for Jenkins)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/0compute/yanc&quot;&gt;yanc&lt;/a&gt; - Output Color-izer&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ischium/xtraceback&quot;&gt;xtraceback&lt;/a&gt; - Better Test Tracebacks&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>Getting Started with Django Rest Framework and AngularJS</title><link>https://blog.kevinastone.com/django-rest-framework-and-angular-js/</link><guid isPermaLink="true">https://blog.kevinastone.com/django-rest-framework-and-angular-js/</guid><pubDate>Wed, 02 Oct 2013 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;A &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;ReSTful API&lt;/a&gt; is becoming a standard component of any modern web application. The &lt;a href=&quot;http://django-rest-framework.org&quot;&gt;Django Rest Framework&lt;/a&gt; is powerful framework for developing ReST endpoints for your Django based project. &lt;a href=&quot;http://angularjs.org&quot;&gt;AngularJS&lt;/a&gt; is modern javascript framework for creating complex web applications within the browser. It focuses on strong separation of concerns (MVC) and dependency injection to encourage creating maintainable (and testable) modules that can be integrated to develop rich client side functionality.&lt;/p&gt;
&lt;p&gt;In this blog post, I&apos;ll walk through creating a sample project that exposes a ReST API consumed by AngularJS on the client to showcase how to combine the frontend and backend frameworks to simplify creating complex applications. I&apos;ll make heavy use of code examples to demonstrate both the solution and the process and there&apos;s a companion &lt;a href=&quot;https://github.com/kevinastone/django-api-rest-and-angular&quot;&gt;Github project&lt;/a&gt; with all the code.&lt;/p&gt;
&lt;h1&gt;Let&apos;s Build a Sample Django Project&lt;/h1&gt;
&lt;p&gt;For a sample project, let&apos;s create a simple photo-sharing app (not unlike a rudimentary Instagram) and build a feed view for a given user to scan through all the photos shared on the site.&lt;/p&gt;
&lt;p&gt;All the sample code for this project is available on a &lt;a href=&quot;https://github.com/kevinastone/django-api-rest-and-angular&quot;&gt;GitHub repository&lt;/a&gt;. To setup the sample project in your own environment, consult the &lt;a href=&quot;https://github.com/kevinastone/django-api-rest-and-angular/blob/master/Readme.markdown&quot;&gt;installation instructions&lt;/a&gt; included in the repository. This includes installing AngularJS (and other javascript assets) via &lt;a href=&quot;http://yeoman.io&quot;&gt;bower+grunt&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, there&apos;s some sample data in fixtures available to demonstrate the API. We have a few users (&lt;code&gt;[&apos;Bob&apos;, &apos;Sally&apos;, &apos;Joe&apos;, &apos;Rachel&apos;]&lt;/code&gt;), two posts (&lt;code&gt;[&apos;This is a great post&apos;, &apos;Another thing I wanted to share&apos;]&lt;/code&gt;) and some sample photos as well. The included Makefile builds the sample data for you.&lt;/p&gt;
&lt;p&gt;Couple notes about the sample code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I&apos;ll skip over the details on configuring, building and running the sample application. There&apos;s &lt;a href=&quot;https://github.com/kevinastone/django-api-rest-and-angular/blob/master/Readme.markdown&quot;&gt;instructions&lt;/a&gt; in the &lt;a href=&quot;https://github.com/kevinastone/django-api-rest-and-angular&quot;&gt;repository&lt;/a&gt; that covers many of these details. Please report any issues on GitHub and I&apos;ll be sure to fix them.&lt;/li&gt;
&lt;li&gt;I&apos;ve written the frontend code using &lt;a href=&quot;http://coffeescript.org&quot;&gt;Coffee-Script&lt;/a&gt; since I find it more legible and more efficient (and a bit more Pythonic). There&apos;s a supplied Grunt task that collects all the coffee script files and concats them into a single &lt;code&gt;script.js&lt;/code&gt; file for inclusion.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Project Data Layer (the Models)&lt;/h2&gt;
&lt;p&gt;Our model layer is straightforward to what you might find in an introductory tutorial for Django. You have three models of note: &lt;code&gt;User&lt;/code&gt;, &lt;code&gt;Post&lt;/code&gt;, and &lt;code&gt;Photo&lt;/code&gt;. A user can author many posts (as well as have many followers) and a post can showcase many photos (such as a collection or gallery) along with a title and optional description/body.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.db import models

from django.contrib.auth.models import AbstractUser


class User(AbstractUser):
    followers = models.ManyToManyField(&apos;self&apos;, related_name=&apos;followees&apos;, symmetrical=False)


class Post(models.Model):
    author = models.ForeignKey(User, related_name=&apos;posts&apos;)
    title = models.CharField(max_length=255)
    body = models.TextField(blank=True, null=True)


class Photo(models.Model):
    post = models.ForeignKey(Post, related_name=&apos;photos&apos;)
    image = models.ImageField(upload_to=&quot;%Y/%m/%d&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Django Rest Framework based API&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&quot;http://django-rest-framework.org&quot;&gt;Django Rest Framework (DRF)&lt;/a&gt; provides a clean architecture to develop both simple, turn-key API endpoints as well as more complex ReST constructs. The key is a clean separation with &lt;code&gt;Serializer&lt;/code&gt; which describes the mapping between a model and the generalized wire representation (be it JSON, XML or whatever) and separate set of generic Class-Based-Views that can be extended to meet the needs of the specific API endpoint. You also define your own URL structure rather than rely on an auto-generated one. This is what separates DRF from other frameworks like &lt;a href=&quot;http://tastypieapi.org&quot;&gt;Tastypie&lt;/a&gt; and &lt;a href=&quot;https://bitbucket.org/jespern/django-piston/wiki/Home&quot;&gt;Piston&lt;/a&gt; that automate much of the conversion from django models to ReST endpoints, but come at the cost of flexibility in adapting to different use cases (especially around permissions and nested resources).&lt;/p&gt;
&lt;h2&gt;Model Serializers&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Serializers&lt;/code&gt; in DRF focus on the responsibility to convert django model instances into their representation in the API. This gives us the opportunity to convert any data types, or provide supplemental information in a given model. For example, for the user, we only included some of the fields, stripping private attributes such as &lt;code&gt;password&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt;. For the photo, we converted the &lt;code&gt;ImageField&lt;/code&gt; to return the url of the image (rather than the media path location).&lt;/p&gt;
&lt;p&gt;For the &lt;code&gt;PostSerializer&lt;/code&gt;, we elected to embed the author directly in the Post (rather the the common case to provide a hyperlink). This makes that information readily accessible to our client rather than requiring extra API requests at the cost of duplicating users on each post. The alternative hyperlink is listed with a comment for comparison. The power of serializers is that you can extend them to create a derivative version, that uses hyperlinks instead of nested records (say, for the case of listing posts by a specific users&apos; feed).&lt;/p&gt;
&lt;p&gt;To assign the &lt;code&gt;author&lt;/code&gt; to the &lt;code&gt;PostSerializer&lt;/code&gt;, we&apos;re gonna have that provided by the API View. So we&apos;ll make it optional (&lt;code&gt;required=False&lt;/code&gt;) in our serializer and add it to the validation exclusion.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from rest_framework import serializers

from .models import User, Post, Photo


class UserSerializer(serializers.ModelSerializer):
    posts = serializers.HyperlinkedIdentityField(&apos;posts&apos;, view_name=&apos;userpost-list&apos;, lookup_field=&apos;username&apos;)

    class Meta:
        model = User
        fields = (&apos;id&apos;, &apos;username&apos;, &apos;first_name&apos;, &apos;last_name&apos;, &apos;posts&apos;, )


class PostSerializer(serializers.ModelSerializer):
    author = UserSerializer(required=False)
    photos = serializers.HyperlinkedIdentityField(&apos;photos&apos;, view_name=&apos;postphoto-list&apos;)
    # author = serializers.HyperlinkedRelatedField(view_name=&apos;user-detail&apos;, lookup_field=&apos;username&apos;)

    def get_validation_exclusions(self):
        # Need to exclude `author` since we&apos;ll add that later based off the request
        exclusions = super(PostSerializer, self).get_validation_exclusions()
        return exclusions + [&apos;author&apos;]

    class Meta:
        model = Post


class PhotoSerializer(serializers.ModelSerializer):
    image = serializers.Field(&apos;image.url&apos;)

    class Meta:
        model = Photo

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Okay, given our samples are fixtures are loaded, let&apos;s play with these serializers. You&apos;ll likely see &lt;code&gt;DeprecationWarning&lt;/code&gt; because we&apos;re using &lt;code&gt;HyperlinkedIdentityField&lt;/code&gt; without providing a request object to construct the URL. In the actual views, this is provided, so you can safely ignore.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from example.api.models import User
&amp;gt;&amp;gt;&amp;gt; user = User.objects.get(username=&apos;bob&apos;)
&amp;gt;&amp;gt;&amp;gt; # Need to generate a fake request for our hyperlinked results
&amp;gt;&amp;gt;&amp;gt; from django.test.client import RequestFactory
&amp;gt;&amp;gt;&amp;gt; from example.api.serializers import *
&amp;gt;&amp;gt;&amp;gt; context = dict(request=RequestFactory().get(&apos;/&apos;))
&amp;gt;&amp;gt;&amp;gt; serializer = UserSerializer(user, context=context)
&amp;gt;&amp;gt;&amp;gt; serializer.data
{&apos;id&apos;: 2, &apos;username&apos;: u&apos;bob&apos;, &apos;first_name&apos;: u&apos;Bob&apos;, &apos;last_name&apos;: u&apos;&apos;, &apos;posts&apos;: &apos;http://testserver/api/users/bob/posts&apos;}
&amp;gt;&amp;gt;&amp;gt; post = user.posts.all()[0]
&amp;gt;&amp;gt;&amp;gt; PostSerializer(post, context=context).data
{&apos;author&apos;: {&apos;id&apos;: 2, &apos;username&apos;: u&apos;bob&apos;, &apos;first_name&apos;: u&apos;Bob&apos;, &apos;last_name&apos;: u&apos;&apos;, &apos;posts&apos;: &apos;http://testserver/api/users/bob/posts&apos;}, &apos;photos&apos;: &apos;http://testserver/api/posts/2/photos&apos;, u&apos;id&apos;: 2, &apos;title&apos;: u&apos;Title #2&apos;, &apos;body&apos;: u&apos;Another thing I wanted to share&apos;}
&amp;gt;&amp;gt;&amp;gt; serializer = PostSerializer(user.posts.all(), many=True, context=context)
&amp;gt;&amp;gt;&amp;gt; serializer.data
[{&apos;author&apos;: {&apos;id&apos;: 2, &apos;username&apos;: u&apos;bob&apos;, &apos;first_name&apos;: u&apos;Bob&apos;, &apos;last_name&apos;: u&apos;&apos;, &apos;posts&apos;: &apos;http://testserver/api/users/bob/posts&apos;}, &apos;photos&apos;: &apos;http://testserver/api/posts/2/photos&apos;, u&apos;id&apos;: 2, &apos;title&apos;: u&apos;Title #2&apos;, &apos;body&apos;: u&apos;Another thing I wanted to share&apos;}]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;API URL Structure&lt;/h2&gt;
&lt;p&gt;For our API structure, we want to maintain a relatively flat structure to try to define canonical endpoints for given resources, but also provide some convenient nested listings for common filterings (such as posts for a given user and photos in a given post). Note that we use model primary keys as the identifier, but for users, we use their username since that&apos;s also unique identifying (we&apos;ll see this later in the views).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.conf.urls import patterns, url, include

from .api import UserList, UserDetail
from .api import PostList, PostDetail, UserPostList
from .api import PhotoList, PhotoDetail, PostPhotoList

user_urls = patterns(&apos;&apos;,
    url(r&apos;^/(?P&amp;lt;username&amp;gt;[0-9a-zA-Z_-]+)/posts$&apos;, UserPostList.as_view(), name=&apos;userpost-list&apos;),
    url(r&apos;^/(?P&amp;lt;username&amp;gt;[0-9a-zA-Z_-]+)$&apos;, UserDetail.as_view(), name=&apos;user-detail&apos;),
    url(r&apos;^$&apos;, UserList.as_view(), name=&apos;user-list&apos;)
)

post_urls = patterns(&apos;&apos;,
    url(r&apos;^/(?P&amp;lt;pk&amp;gt;\d+)/photos$&apos;, PostPhotoList.as_view(), name=&apos;postphoto-list&apos;),
    url(r&apos;^/(?P&amp;lt;pk&amp;gt;\d+)$&apos;, PostDetail.as_view(), name=&apos;post-detail&apos;),
    url(r&apos;^$&apos;, PostList.as_view(), name=&apos;post-list&apos;)
)

photo_urls = patterns(&apos;&apos;,
    url(r&apos;^/(?P&amp;lt;pk&amp;gt;\d+)$&apos;, PhotoDetail.as_view(), name=&apos;photo-detail&apos;),
    url(r&apos;^$&apos;, PhotoList.as_view(), name=&apos;photo-list&apos;)
)

urlpatterns = patterns(&apos;&apos;,
    url(r&apos;^users&apos;, include(user_urls)),
    url(r&apos;^posts&apos;, include(post_urls)),
    url(r&apos;^photos&apos;, include(photo_urls)),
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;API Views&lt;/h2&gt;
&lt;p&gt;Much of the power of Django Rest Framework is that the generic views make it easy to work with the common &lt;a href=&quot;http://en.wikipedia.org/wiki/Create,_read,_update_and_delete&quot;&gt;CRUD&lt;/a&gt; cases with little or no modifications. For the simplest views, you provide a &lt;code&gt;model&lt;/code&gt; and a &lt;code&gt;serializer_class&lt;/code&gt; and extend one of the built in generics (like &lt;code&gt;ListAPIView&lt;/code&gt; or &lt;code&gt;RetrieveAPIView&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;For our use case, we have a couple customizations. First, for users, we wanted to use &lt;code&gt;username&lt;/code&gt; as the lookup field rather than &lt;code&gt;pk&lt;/code&gt;. So we set &lt;code&gt;lookup_field&lt;/code&gt; on the view (by default it&apos;s both the &lt;code&gt;url_kwarg&lt;/code&gt; and the field name on the model).&lt;/p&gt;
&lt;p&gt;We also wanted to create nested versions of the views for a given user&apos;s posts or the photos within a post. You simply override &lt;code&gt;get_queryset&lt;/code&gt; on the view to customize the queryset to filter down the results based on the nested parameters (&lt;code&gt;username&lt;/code&gt; and &lt;code&gt;pk&lt;/code&gt; respectively).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from rest_framework import generics, permissions


from .serializers import UserSerializer, PostSerializer, PhotoSerializer
from .models import User, Post, Photo


class UserList(generics.ListCreateAPIView):
    model = User
    queryset = User.objects.all()
    serializer_class = UserSerializer
    permission_classes = [
        permissions.AllowAny
    ]


class UserDetail(generics.RetrieveAPIView):
    model = User
    queryset = User.objects.all()
    serializer_class = UserSerializer
    lookup_field = &apos;username&apos;


class PostList(generics.ListCreateAPIView):
    model = Post
    queryset = Post.objects.all()
    serializer_class = PostSerializer
    permission_classes = [
        permissions.AllowAny
    ]


class PostDetail(generics.RetrieveUpdateDestroyAPIView):
    model = Post
    queryset = Post.objects.all()
    serializer_class = PostSerializer
    permission_classes = [
        permissions.AllowAny
    ]


class UserPostList(generics.ListAPIView):
    model = Post
    queryset = Post.objects.all()
    serializer_class = PostSerializer

    def get_queryset(self):
        queryset = super(UserPostList, self).get_queryset()
        return queryset.filter(author__username=self.kwargs.get(&apos;username&apos;))


class PhotoList(generics.ListCreateAPIView):
    model = Photo
    queryset = Photo.objects.all()
    serializer_class = PhotoSerializer
    permission_classes = [
        permissions.AllowAny
    ]


class PhotoDetail(generics.RetrieveUpdateDestroyAPIView):
    model = Photo
    queryset = Photo.objects.all()
    serializer_class = PhotoSerializer
    permission_classes = [
        permissions.AllowAny
    ]


class PostPhotoList(generics.ListAPIView):
    model = Photo
    queryset = Photo.objects.all()
    serializer_class = PhotoSerializer

    def get_queryset(self):
        queryset = super(PostPhotoList, self).get_queryset()
        return queryset.filter(post__pk=self.kwargs.get(&apos;pk&apos;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Interlude: Built-in API Browser&lt;/h2&gt;
&lt;p&gt;One of the benefits of Django Rest Framework, is that it comes with a built-in API browser for testing out your API. Much like Django&apos;s admin, this can help with initial development.&lt;/p&gt;
&lt;p&gt;Simple load one of your API endpoints in the browser, and through content-negotiation, DRF will present to you a handy client interface to interact with your API.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/django-rest-framework-and-angular-js/browser_users.png&quot; alt=&quot;API Browser Example for Users&quot; /&gt;
&lt;img src=&quot;images/django-rest-framework-and-angular-js/browser_user_posts.png&quot; alt=&quot;API Browser Example for User Posts&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Add Permissions and Ownership to API&lt;/h2&gt;
&lt;p&gt;As previously written, our API Views allow anyone to create anything on our site. Some of the advantages of using Django Rest Framework, is that the generic views make it easy to control permissions in the view without impact the underlying model and serializers. To incorporate some control over who is allowed to edit our API resources, we can created some permission classes that provide the authorization controls to restrict. They should return a boolean for the given request. This gives us access to the full request including cookies, the authenticated user and more.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from rest_framework import permissions


class SafeMethodsOnlyPermission(permissions.BasePermission):
    &quot;&quot;&quot;Only can access non-destructive methods (like GET and HEAD)&quot;&quot;&quot;
    def has_permission(self, request, view):
        return self.has_object_permission(request, view)

    def has_object_permission(self, request, view, obj=None):
        return request.method in permissions.SAFE_METHODS


class PostAuthorCanEditPermission(SafeMethodsOnlyPermission):
    &quot;&quot;&quot;Allow everyone to list or view, but only the other can modify existing instances&quot;&quot;&quot;
    def has_object_permission(self, request, view, obj=None):
        if obj is None:
            # Either a list or a create, so no author
            can_edit = True
        else:
            can_edit = request.user == obj.author
        return can_edit or super(PostAuthorCanEditPermission, self).has_object_permission(request, view, obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Besides simple authorization decisions, we also want to pre-fill values on save depending on who makes the requests. When someone creates a new &lt;code&gt;Post&lt;/code&gt;, we want to assign them as the author. Because of the duplication between &lt;code&gt;PostList&lt;/code&gt; and &lt;code&gt;PostDetail&lt;/code&gt;, we can create a mixin class that holds all the common configuration (you can also use [ViewSets][viewsets] to accomplish similar consolidation).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class PostMixin(object):
    model = Post
    queryset = Post.objects.all()
    serializer_class = PostSerializer
    permission_classes = [
        PostAuthorCanEditPermission
    ]

    def perform_create(self, serializer):
        &quot;&quot;&quot;Force author to the current user on save&quot;&quot;&quot;
        serializer.save(author=self.request.user)


class PostList(PostMixin, generics.ListCreateAPIView):
    pass


class PostDetail(PostMixin, generics.RetrieveUpdateDestroyAPIView):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Consume the API using AngularJS&lt;/h1&gt;
&lt;p&gt;With the advent of more interactive web applications, a ReSTful API can be leveraged by rich client interfaces to expose and interact with your application&apos;s data model. AngularJS is a great companion because of its clean separation of controls. AngularJS&apos;s modular architecture involves a little bit of setup. Your app is composed of modules which define services, directives and controllers that compartmentalize the functionality for cleaner separation.&lt;/p&gt;
&lt;p&gt;Part of the power of AngularJS, is that it provides &lt;a href=&quot;http://en.wikipedia.org/wiki/Reactive_programming&quot;&gt;reactive programming&lt;/a&gt; leveraging their javascript-like expression language. We can simply define a template that references variables, and our page will automatically refresh when changes are made to those variables.&lt;/p&gt;
&lt;p&gt;For the &lt;em&gt;hello world&lt;/em&gt; style intro, we&apos;ll simply list the posts in our sample application. Here is a bare bones template in AngularJS. First, at the top level on the body tag, we specify which angular app we are using to run this page (&lt;code&gt;example.app.basic&lt;/code&gt;), which is where we&apos;ll define the root module. Second, we need to specific the controller to manage our section (&lt;code&gt;AppController&lt;/code&gt;). The controller in AngularJS parlance is really more like the model+controller in the traditional MVC (with the injected &lt;code&gt;$scope&lt;/code&gt; containing the model state). Controllers define scopes that hold the actual model instances and they can be nested to narrow the scope of your system as your go down the DOM. Finally, we leverage an Angular directive (&lt;code&gt;ng-repeat&lt;/code&gt;) which is a control structure to iterate over our &lt;code&gt;posts&lt;/code&gt; model stored in the &lt;code&gt;$state&lt;/code&gt;. Within that iteration, we define a few tags and use the angular expression syntax (kinda like django template tags) to print out the username of the author, and the title and body of the post.&lt;/p&gt;
&lt;p&gt;*Note: Use verbatim tags to encapsulate the AngularJS expressions so that django doesn&apos;t attempt to render them.&lt;/p&gt;
&lt;p&gt;*Note: I&apos;ve enclosed some sections in Django &lt;code&gt;{% block %}&lt;/code&gt; tags so I can extend this template for each example.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{% load staticfiles %}

&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{% static &quot;bootstrap/dist/css/bootstrap.css&quot; %}&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body ng-app=&quot;{% block ng_app %}example.app.static{% endblock %}&quot;&amp;gt;
&amp;lt;div class=&quot;content&quot; ng-controller=&quot;{% block ng_controller %}AppController{% endblock %}&quot;&amp;gt;{% block content %}
{% verbatim %}
    &amp;lt;div class=&quot;panel&quot; ng-repeat=&quot;post in posts&quot;&amp;gt;
        &amp;lt;div class=&quot;panel-heading clearfix&quot;&amp;gt;
            &amp;lt;h3 class=&quot;panel-title&quot;&amp;gt;{{ post.title }}&amp;lt;/h3&amp;gt;
            &amp;lt;author class=&quot;pull-right&quot;&amp;gt;{{ post.author.username }}&amp;lt;/author&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;p class=&quot;well&quot;&amp;gt;{{ post.body }}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
{% endverbatim %}
{% endblock %}&amp;lt;/div&amp;gt;
&amp;lt;script src=&quot;{% static &quot;underscore/underscore.js&quot; %}&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;{% static &quot;angular/angular.js&quot; %}&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;{% static &quot;angular-resource/angular-resource.js&quot; %}&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;{% static &quot;js/script.js&quot; %}&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let&apos;s pair this template with a simple controller that will supply the list of posts. We&apos;ll hard-code the posts for now and then pull them in with Ajax in the next step.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app = angular.module &apos;example.app.static&apos;, []

app.controller &apos;AppController&apos;, [&apos;$scope&apos;, &apos;$http&apos;, ($scope, $http) -&amp;gt;
    $scope.posts = [
        author:
            username: &apos;Joe&apos;
        title: &apos;Sample Post #1&apos;
        body: &apos;This is the first sample post&apos;
    ,
        author:
            username: &apos;Karen&apos;
        title: &apos;Sample Post #2&apos;
        body: &apos;This is another sample post&apos;
    ]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you&apos;ve got everything setup and run grunt to compile this down to javascript, you should see our &lt;a href=&quot;http://localhost:8000/static&quot;&gt;hard-coded template&lt;/a&gt; rendered as such:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/django-rest-framework-and-angular-js/example_static.png&quot; alt=&quot;Basic Post List - Hard Coded&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Using XHR to Pull Posts from the API&lt;/h3&gt;
&lt;p&gt;Now, let&apos;s go ahead and update or controller to instead grab the list of posts from our API endpoint. The &lt;code&gt;$http&lt;/code&gt; service for AngularJS is similar to jQuery&apos;s &lt;code&gt;$.ajax&lt;/code&gt; or other XHR implementations. Notice, with AngularJS, we simply updated our model (&lt;code&gt;$scope.posts&lt;/code&gt;) with the result of the ajax call, and our view is automatically updated in sync. No need to manipulate the DOM. This reactive style allows us to develop complex UIs with interdependencies between our data model and have the UI components respond appropriately without directly managing those connections, keeping our views and model layers loosely-coupled.&lt;/p&gt;
&lt;p&gt;*Note the use of the promise chaining (&lt;code&gt;.then()&lt;/code&gt;) on the &lt;code&gt;$http&lt;/code&gt; call. You could just as easily pass a callback. You can take advantage of promise chaining to develop more complex API workflows such as creating a new post and then saving 3 photos.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app = angular.module &apos;example.app.basic&apos;, []

app.controller &apos;AppController&apos;, [&apos;$scope&apos;, &apos;$http&apos;, ($scope, $http) -&amp;gt;
    $scope.posts = []
    $http.get(&apos;/api/posts&apos;).then (result) -&amp;gt;
        angular.forEach result.data, (item) -&amp;gt;
            $scope.posts.push item
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With &lt;code&gt;$http&lt;/code&gt; pulling the list of posts from our API, our &lt;a href=&quot;http://localhost:8000/basic&quot;&gt;example page&lt;/a&gt; now shows a feed of posts from the server.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/django-rest-framework-and-angular-js/example_basic.png&quot; alt=&quot;Basic Post List - XHR&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Leveraging Angular-Resource for API&lt;/h2&gt;
&lt;p&gt;While &lt;code&gt;$http&lt;/code&gt; allows us to make the XHR calls to pull the API data into our app, it&apos;s forcing us to hard code many details about our API, including constructing the URLs, http verbs and other aspects that could be encapsulated in a higher level construct. Enter &lt;a href=&quot;http://docs.angularjs.org/api/ngResource&quot;&gt;Angular-Resource&lt;/a&gt;, which provides a mechanism to define our API through Angular services that manage much of the lower level http requirements for us leaving simple ReSTful verbs to interact with the API.&lt;/p&gt;
&lt;p&gt;To work with Angular-Resource (or ngResource), you simply define the mapping between your API endpoints and the parameters in the URL pattern (much like Django &lt;code&gt;urlpatterns&lt;/code&gt;). Unfortunately, it&apos;s not terribly easy to convert between Django and the ngResource definitions, so the DRY isn&apos;t quite there.&lt;/p&gt;
&lt;p&gt;When you define your resources (using &lt;code&gt;$resource&lt;/code&gt;), you simple provide a url pattern, a list of default parameter mappings, and optionally some additional http methods. In our case, we want the resource for &lt;code&gt;User&lt;/code&gt; to pull the &lt;code&gt;:username&lt;/code&gt; parameter in the URL from the &lt;code&gt;username&lt;/code&gt; field on our resource instance. &lt;code&gt;Post&lt;/code&gt; and &lt;code&gt;Photo&lt;/code&gt; use the &lt;code&gt;id&lt;/code&gt; field on the instance accordingly as the primary key.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app = angular.module &apos;example.api&apos;, [&apos;ngResource&apos;]

app.factory &apos;User&apos;, [&apos;$resource&apos;, ($resource) -&amp;gt;
    $resource &apos;/api/users/:username&apos;, username: &apos;@username&apos;
]

app.factory &apos;Post&apos;, [&apos;$resource&apos;, ($resource) -&amp;gt;
    $resource &apos;/api/posts/:id&apos;, id: &apos;@id&apos;
]

app.factory &apos;Photo&apos;, [&apos;$resource&apos;, ($resource) -&amp;gt;
    $resource &apos;/api/photos/:id&apos;, id: &apos;@id&apos;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we&apos;ve defined our api module, we can use it as a dependency in our controller module and inject those API resources as services that our controller can use to access the API. We add &lt;code&gt;example.api&lt;/code&gt; as a dependent module and list any API resources as dependencies in our controller definition. By default, your resources have many of the basic CRUD methods including &lt;code&gt;query()&lt;/code&gt; (for retrieving a collection), &lt;code&gt;get()&lt;/code&gt; (for individual items), &lt;code&gt;save()&lt;/code&gt;, &lt;code&gt;delete()&lt;/code&gt;, and so on.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app = angular.module &apos;example.app.resource&apos;, [&apos;example.api&apos;]

app.controller &apos;AppController&apos;, [&apos;$scope&apos;, &apos;Post&apos;, ($scope, Post) -&amp;gt;
    $scope.posts = Post.query()
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which results in the same list of Posts as above on the &lt;a href=&quot;http://localhost:8000/resource&quot;&gt;example page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/django-rest-framework-and-angular-js/example_resource.png&quot; alt=&quot;Basic Post List - Resource&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Add the Photos to our Post Feed&lt;/h2&gt;
&lt;p&gt;We now have our feed of posts displaying using &lt;code&gt;ngResource&lt;/code&gt; API calls, but we&apos;re simply making one call to retrieve the data. In real applications, your data is rarely stored at only a single resource endpoint and will require coordinated API calls to construct your applications model state. Let&apos;s enhance our app to also retrieve the photos from each post and display them as well to explore this.&lt;/p&gt;
&lt;p&gt;First, let&apos;s add two other resources for the nested API calls:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app.factory &apos;UserPost&apos;, [&apos;$resource&apos;, ($resource) -&amp;gt;
    $resource &apos;/api/users/:username/posts/:id&apos;
]

app.factory &apos;PostPhoto&apos;, [&apos;$resource&apos;, ($resource) -&amp;gt;
    $resource &apos;/api/posts/:post_id/photos/:id&apos;
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will provide two more services (&lt;code&gt;UserPost&lt;/code&gt; and &lt;code&gt;PostPhoto&lt;/code&gt;) that we can query to retrieve resources for a given user and post respectively. As nested resources, we want to wire up AngularJS to load them after loading the base resource (another option is to use angular&apos;s &lt;code&gt;$watch&lt;/code&gt; mechanism to response to changes and trigger additional API calls). For this, we want to leverage Angular&apos;s &lt;code&gt;$q&lt;/code&gt; service which provides a Promise/Deferred implementation allowing us to chain calls. Starting with ngResource-1.1+, each resource provides a $promise attribute which you can chain against. We are going to leverage that interface to make a follow on API call to retrieve photos for a given post.&lt;/p&gt;
&lt;p&gt;You have a couple of choices on how to handle the nesting of resources. For this case, we will simply create another container on our &lt;code&gt;$scope&lt;/code&gt; for the photos and use the post_id as the identifier. Angular&apos;s expression and template language ignores missing keys, so we can simply iterate over &lt;code&gt;photos[post.id]&lt;/code&gt; to retrieve the photos in the template. Notice how we don&apos;t have to signal to change the view/template. Angular&apos;s &lt;code&gt;$digest&lt;/code&gt; process detects the updates (it&apos;s also well integrated with &lt;code&gt;ngResoruce&lt;/code&gt; and &lt;code&gt;$q&lt;/code&gt;s).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app = angular.module &apos;example.app.photos&apos;, [&apos;example.api&apos;]

app.controller &apos;AppController&apos;, [&apos;$scope&apos;, &apos;Post&apos;, &apos;PostPhoto&apos;, ($scope, Post, PostPhoto) -&amp;gt;
    $scope.photos = {}
    $scope.posts = Post.query()
    $scope.posts.$promise.then (results) -&amp;gt;
        # Load the photos
        angular.forEach results, (post) -&amp;gt;
            $scope.photos[post.id] = PostPhoto.query(post_id: post.id)
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And also update our template to iterate over this model to display photos in each post. Notice how AngularJS re-renders the view as the data is loaded from the API. In this case, we are iterating over the photos object referenced by the id of the post we were iterating in the parent &lt;code&gt;ng-repeat&lt;/code&gt;. We also used &lt;code&gt;ng-src&lt;/code&gt; instead of &lt;code&gt;src&lt;/code&gt; because it prevents browsers from attempting to load an image before the angular expression language has been evaluated (you&apos;ll see 404s in your logs around can&apos;t find: &apos;/media/{{ photo.image }}&apos;).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;panel&quot; ng-repeat=&quot;post in posts&quot;&amp;gt;
    &amp;lt;div class=&quot;panel-heading clearfix&quot;&amp;gt;
        &amp;lt;h3 class=&quot;pull-left panel-title&quot;&amp;gt;{{ post.title }}&amp;lt;/h3&amp;gt;
        &amp;lt;author class=&quot;pull-right&quot;&amp;gt;{{ post.author.username }}&amp;lt;/author&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;p class=&quot;well&quot;&amp;gt;{{ post.body }}&amp;lt;/p&amp;gt;
    &amp;lt;span class=&quot;photo&quot; ng-repeat=&quot;photo in photos[post.id]&quot;&amp;gt;
        &amp;lt;img class=&quot;img-thumbnail&quot; ng-src=&quot;{{ photo.image }}&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally, our updated &lt;a href=&quot;http://localhost:8000/photos&quot;&gt;example page&lt;/a&gt; rendered with photos.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/django-rest-framework-and-angular-js/example_photos.png&quot; alt=&quot;Basic Post List - Photos&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Interlude: AngularJS + CSRF Protection&lt;/h2&gt;
&lt;p&gt;Django Rest Framework extends Django&apos;s &lt;a href=&quot;https://docs.djangoproject.com/en/dev/ref/contrib/csrf/&quot;&gt;Cross Site Request Forgery&lt;/a&gt; protection when using &lt;code&gt;SessionAuthentication&lt;/code&gt; (such as our case using the same browser session as the web application). This helps ensure malicious scripts can&apos;t coax our users into making inadvertent calls to our API by forcing the scripts to return a server provided token on each call. AngularJS&apos;s modular architecture and dependency injection configuration make this simple to configure our API calls to include the CSRF Token in a header (you can also use a cookie if you prefer).&lt;/p&gt;
&lt;p&gt;In our django template, simply add a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to configure the &lt;code&gt;$http&lt;/code&gt; provider (AngularJS parlance for the implementation of the &lt;code&gt;$http&lt;/code&gt; dependency) and customize it to use the Django &lt;code&gt;{{ csrf_token }}&lt;/code&gt; template variable to set the CSRF Header on all API calls.&lt;/p&gt;
&lt;p&gt;*Note: Make sure this script is loaded &lt;strong&gt;after&lt;/strong&gt; your module definitions.&lt;/p&gt;
&lt;p&gt;*Note: You can pass the CSRF token between Angular and Django through cookies or other mechanisms. This explicit header mechanism just ensures the &lt;code&gt;csrf token&lt;/code&gt; is generated on every request.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    // Add the CSRF Token
    var app = angular.module(&apos;example.app&apos;); // Not including a list of dependent modules (2nd parameter to `module`) &quot;re-opens&quot; the module for additional configuration
    app.config([
        &apos;$httpProvider&apos;,
        function ($httpProvider) {
            $httpProvider.defaults.headers.common[&apos;X-CSRFToken&apos;] =
                &apos;{{ csrf_token|escapejs }}&apos;;
        },
    ]);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Creating/Modifying API Resource using AngularJS&lt;/h1&gt;
&lt;p&gt;Let&apos;s now build an editor in our feed view to publish a new post (such as a Facebook status update). While most Angular tutorials would just add the functionality to the existing controller on the page, we want to show how to keep your controllers lean and modular, so we&apos;ll create a separate controller for this post editor and show how controllers leverage the nesting of the model scopes to extend functionality. This also gives a chance to extend our existing module &lt;code&gt;example.app.photos&lt;/code&gt; which provides our base &lt;code&gt;AppController&lt;/code&gt; for the feed.&lt;/p&gt;
&lt;p&gt;First, we need to extend our base template, and add the html template for the editor. We also add the CSRF token from the above instructions since we&apos;ll now send unsafe methods to our API to save the new posts.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{% extends &apos;base.html&apos; %} {% block ng_app %}example.app.editor{% endblock %} {%
block content %} {% verbatim %}
&amp;lt;div ng-controller=&quot;EditController&quot;&amp;gt;
    &amp;lt;h5&amp;gt;Create a New Post&amp;lt;/h5&amp;gt;
    &amp;lt;form class=&quot;form-inline&quot;&amp;gt;
        &amp;lt;div class=&quot;form-group block-level&quot;&amp;gt;
            &amp;lt;input
                type=&quot;text&quot;
                class=&quot;form-control&quot;
                ng-model=&quot;newPost.title&quot;
                placeholder=&quot;Title&quot;
            /&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;input
                type=&quot;text&quot;
                class=&quot;form-control&quot;
                ng-model=&quot;newPost.body&quot;
                placeholder=&quot;Body&quot;
            /&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;button class=&quot;btn btn-default&quot; ng-click=&quot;save()&quot;&amp;gt;Add Post&amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
{% endverbatim %} {{ block.super }} {% endblock %} {% block js %} {{ block.super
}}
&amp;lt;script&amp;gt;
    // Add the CSRF Token
    var app = angular.module(&apos;example.app.editor&apos;); // Not including a list of dependent modules (2nd parameter to `module`) &quot;re-opens&quot; the module for additional configuration
    app.config([
        &apos;$httpProvider&apos;,
        function($httpProvider) {
            $httpProvider.defaults.headers.common[&apos;X-CSRFToken&apos;] =
                &apos;{{ csrf_token|escapejs }}&apos;;
        },
    ]);
&amp;lt;/script&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we have our editor, let&apos;s build the controller to wire this up. Notice that we depend on two modules now, the base module for our feed and the api module that contains all our &lt;code&gt;$resource&lt;/code&gt; definitions.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app = angular.module &apos;example.app.editor&apos;, [&apos;example.api&apos;, &apos;example.app.photos&apos;]

app.controller &apos;EditController&apos;, [&apos;$scope&apos;, &apos;Post&apos;, ($scope, Post) -&amp;gt;

    $scope.newPost = new Post()
    $scope.save = -&amp;gt;
        $scope.newPost.$save().then (result) -&amp;gt;
            $scope.posts.push result
        .then -&amp;gt;
            # Reset our editor to a new blank post
            $scope.newPost = new Post()
]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Previously, in the API Views, we added some permission constraints to prevent other users from modifying someone&apos;s posts. Up until now, it didn&apos;t matter what user were acting as. Now that we want to create users, we need to ensure that we&apos;re authenticated as a valid user (or our API request to create a post will be denied). For this demonstration, there&apos;s a quick hack Django Authentication Backend that automatically logs you in root. Obviously, don&apos;t run this in production or any untrusted environment. This is just to help test our sandbox app without dealing with user registration and authentication.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/django-rest-framework-and-angular-js/example_editor.png&quot; alt=&quot;Basic Post List - Editor&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Error Handling&lt;/h2&gt;
&lt;p&gt;If you&apos;re following along, have you tried creating a post without a title? We set that as a required field in the Django model, and Django Rest Framework will validate before creating the resource. If you try to create a Post without a title (say, using the API Browser or our new form), you&apos;d see a 400 Bad Request response, with content that the reasons for the failed request. Let&apos;s leverage that response to inform the user.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;title&quot;: [&quot;This field is required.&quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To inform the user, let&apos;s amend our API call. Since we&apos;re using Promises, we can simply add an error callback to capture that response and notify the user by capturing the response in our &lt;code&gt;$scope&lt;/code&gt; which our template can them update to show the messages to the user.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app = angular.module &apos;example.app.editor&apos;, [&apos;example.api&apos;, &apos;example.app.photos&apos;]

app.controller &apos;EditController&apos;, [&apos;$scope&apos;, &apos;Post&apos;, ($scope, Post) -&amp;gt;

    $scope.newPost = new Post()
    $scope.save = -&amp;gt;
        $scope.newPost.$save().then (result) -&amp;gt;
            $scope.posts.push result
        .then -&amp;gt;
            # Reset our editor to a new blank post
            $scope.newPost = new Post()
        .then -&amp;gt;
            # Clear any errors
            $scope.errors = null
        , (rejection) -&amp;gt;
            $scope.errors = rejection.data
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And also update our template to include a handy error display:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p ng-repeat=&quot;(name, errs) in errors&quot; class=&quot;alert alert-danger&quot;&amp;gt;
    &amp;lt;strong&amp;gt;{{ name }}&amp;lt;/strong&amp;gt;: {{ errs.join(&apos;, &apos;) }}
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By leveraging promise APIs, it makes it straightforward to add UI elements to give feedback about the progress (loading indicators, progress bars) by simply chaining them. AngularJS has a fairly complete Promises/A spec ensuring errors (or rejections) fall-through the chain making error handling simpler.&lt;/p&gt;
&lt;p&gt;For this simple demonstration, we just enumerate the errors in bootstrap alert boxes. Because the errors are identified by attribute name, you can easily update your template to show errors in-line next the form fields they correspond with.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/django-rest-framework-and-angular-js/example_error.png&quot; alt=&quot;Basic Post List - Error&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Remove Your Posts&lt;/h2&gt;
&lt;p&gt;To compliment the editor, we need a way to delete any posts, but only added by the current user. We already instrumented the API to prevent users from trying to modify/delete resources they don&apos;t own. When you&apos;re new to AngularJS, the modular nature makes it difficult to understand how to provide some initial data to the controller. In our case, we need to know who the current user is, so we can control what posts are available to be deleted.&lt;/p&gt;
&lt;p&gt;The key to understanding this is to try to de-compose your controllers into many services/factories (they&apos;re basically synonymous in angular) that handle the actual logic. The controller (much like a view in Django) should really only focus on wiring together different components. In Django, you attempt to integrate as much of your business logic in the model (the fat-model pattern). In Angular, you similarly want to compartmentalize your logic into composable services.&lt;/p&gt;
&lt;p&gt;To add the ability to remove posts, let&apos;s first add a module extending our editor and adding an extra controller for handling the removal. We will depend on a service named &lt;code&gt;AuthUser&lt;/code&gt; which the template will provide with the current user from the Django template context. In this case, it will simply contain a single &lt;code&gt;username&lt;/code&gt; attribute for the current user (our empty if no user). We added two functions on the scope, &lt;code&gt;canDelete&lt;/code&gt; to determine if a given post can be removed by the user, and &lt;code&gt;delete&lt;/code&gt; to remove the post. Both take a &lt;code&gt;post&lt;/code&gt; argument which we will supply in our template.&lt;/p&gt;
&lt;p&gt;Again, we used the Promises interface of the &lt;code&gt;$resource&lt;/code&gt; and only after successful confirmation from the server do we remove the post from our feed view. As above, there&apos;s opportunity for capturing failure results and providing feedback to the user that we&apos;ve skipped in this simple example.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app = angular.module &apos;example.app.manage&apos;, [&apos;example.api&apos;, &apos;example.app.editor&apos;]

app.controller &apos;DeleteController&apos;, [&apos;$scope&apos;, &apos;AuthUser&apos;, ($scope, AuthUser) -&amp;gt;
    $scope.canDelete = (post) -&amp;gt;
        return post.author.username == AuthUser.username

    $scope.delete = (post) -&amp;gt;
        post.$delete()
        .then -&amp;gt;
            # Remove it from the list on success
            idx = $scope.posts.indexOf(post)
            $scope.posts.splice(idx, 1)
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the controller defined, let&apos;s update our Post template to include a close button (with the condition that &lt;code&gt;canDelete&lt;/code&gt; is true).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{% extends &apos;editor.html&apos; %} {% block ng_app %}example.app.manage{% endblock %}
{% block post_header %}

&amp;lt;button
    type=&quot;button&quot;
    class=&quot;close&quot;
    ng-controller=&quot;DeleteController&quot;
    ng-click=&quot;delete(post)&quot;
    ng-show=&quot;canDelete(post)&quot;
&amp;gt;
    &amp;amp;times;
&amp;lt;/button&amp;gt;
{{ block.super }} {% endblock %} {% block js %} {{ block.super }}
&amp;lt;script&amp;gt;
    // Configure the current user
    var app = angular.module(&apos;example.app.manage&apos;); // Not including a list of dependent modules (2nd parameter to `module`) &quot;re-opens&quot; the module for

    app.factory(&apos;AuthUser&apos;, function() {
        return {
            username: &quot;{{ user.username|default:&apos;&apos;|escapejs }}&quot;,
        };
    });
&amp;lt;/script&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And, when you load the &lt;a href=&quot;http://localhost:8000/manage&quot;&gt;example page&lt;/a&gt;, there&apos;s an &lt;em&gt;&apos;X&apos;&lt;/em&gt; next to the post by &lt;code&gt;root&lt;/code&gt;, but not next to the post by &lt;code&gt;bob&lt;/code&gt;. Clicking the X calls our API and deletes the post.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/django-rest-framework-and-angular-js/example_managed.png&quot; alt=&quot;Basic Post List - Removal&quot; /&gt;&lt;/p&gt;
&lt;p&gt;And with that, we have a simple shared feed for a users to share messages.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Alright, let&apos;s reflect. With a small amount of code (~100 lines of frontend, ~200 lines of backend), leveraging Django Rest Frameowrk (+Django itself) and AngularJS, we were able to quickly create a sample application to create simple postings. DRF makes it simple to export our Django data models through a ReSTful API layer with opportunities to customize the interfaces based on our use cases. AngularJS makes it easier to consume and interact with the API in a manner that is more modular and structured to help us add incremental capability to our web apps without creating spaghetti code.&lt;/p&gt;
&lt;p&gt;All the code referenced in this article is available on a &lt;a href=&quot;https://github.com/kevinastone/django-api-rest-and-angular&quot;&gt;GitHub project&lt;/a&gt;. You&apos;re encouraged to checkout the repository and setup your own working copy to experiment. If you see any mistakes, please leave an Issue (or better yet, a Pull-Request) and I&apos;ll be sure to correct it. If you have any questions, please leave me a comment (or hit me up on Twitter at &lt;a href=&quot;https://twitter.com/kevinastone&quot;&gt;@kevinastone&lt;/a&gt;). I intend to follow this article up with more solutions for DRF+Angular that I&apos;ve come across, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pagination&lt;/li&gt;
&lt;li&gt;Singleton Endpoints (toggle follow/unfollow)&lt;/li&gt;
&lt;li&gt;More Complex Permissions&lt;/li&gt;
&lt;li&gt;Richer Validation&lt;/li&gt;
&lt;li&gt;Testing&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>ElasticSearch Bliss with ElasticUtils</title><link>https://blog.kevinastone.com/elasticutils/</link><guid isPermaLink="true">https://blog.kevinastone.com/elasticutils/</guid><pubDate>Mon, 30 Dec 2013 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;While &lt;a href=&quot;http://haystacksearch.org&quot;&gt;Django Haystack&lt;/a&gt; remains the go to recommendation for adding simple search indexing to your Django sites, you can quickly outgrow the simplified &quot;bag of text&quot; data model that haystack attempts to unify the various supported indexing engines. Depending on your use case, you eventually need to customize the tokenizers, scoring, spell correct, autocomplete, etc. These more advanced use cases no longer work commonly across backends forcing you to leave the comfort of Haystack for native APIs for your chosen indexer. &lt;a href=&quot;https://github.com/mozilla/elasticutils&quot;&gt;ElasticUtils&lt;/a&gt; is a newer project from the fine folks at &lt;a href=&quot;http://www.mozilla.org/&quot;&gt;Mozilla&lt;/a&gt; that exposes much of the rich capabilities of &lt;a href=&quot;http://www.elasticsearch.org&quot;&gt;ElasticSearch&lt;/a&gt; in a more elegant, pythonic interface. Much like an &lt;a href=&quot;http://en.wikipedia.org/wiki/Object-relational_mapping&quot;&gt;ORM&lt;/a&gt; can simplify the process of generating SQL for your databsae queries, ElasticUtils provides a streamlined interface for generating search queries for the &lt;a href=&quot;http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.html&quot;&gt;ElasticSearch Query DSL&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Why ElasticSearch&lt;/h1&gt;
&lt;p&gt;Why &lt;a href=&quot;http://www.elasticsearch.org&quot;&gt;ElasticSearch&lt;/a&gt; could really be its own blog post. It&apos;s an immensely powerful search indexing system built on top of the rock solid &lt;a href=&quot;http://lucene.apache.org&quot;&gt;Lucene&lt;/a&gt; library. It features a considerable number of built in query and filter types that allow great range in the type of search conditions allowed. In addition, it has many customizable tokenizers, analyzers and filters to transform your documents into readily identified search results. It&apos;s most frequently compared to &lt;a href=&quot;http://lucene.apache.org/solr/&quot;&gt;SOLR&lt;/a&gt; (which is also Lucene based), which provides similar features. Comparatively, the ReST based API interface of ElasticSearch shifts much of the data definition and configuration to the client, eliminating the burdensome and more rigid system administration challenges of SOLR. Finally, ElasticSearch (as the name gives away), was built with clustering in mind from the start, providing a pathway to sharding your dataset relatively seamlessly for scalability as your system grows.&lt;/p&gt;
&lt;p&gt;Having said that, ElasticSearch is a powerful, but intricate search system. Don&apos;t expect to be able to bolt it on to a project for a simple full-text search, there&apos;s likely easier solutions on the market. There&apos;s a lot of knobs and parameters, and you&apos;re going to need to make an investment to fully understand the ElasticSearch architecture. ElasticUtils doesn&apos;t really attempt to abstract away those details in the way that &lt;a href=&quot;http://haystacksearch.org&quot;&gt;Django Haystack&lt;/a&gt; may. It does have rather sensible defaults though, that make getting started more of a weekend project than a month long sabbatical.&lt;/p&gt;
&lt;p&gt;Ironically, ElasticSearch&apos;s flexibility has opened it up to non-traditional indexing use cases such as &lt;a href=&quot;http://logstash.net&quot;&gt;log management&lt;/a&gt;, analytics and data mining.&lt;/p&gt;
&lt;h1&gt;ElasticUtils in Action&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://www.elasticsearch.org&quot;&gt;ElasticSearch&lt;/a&gt; allows creating rich, complex search queries using a &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;ReSTful API&lt;/a&gt;. Beyond the basic, find documents that match the given terms, you can filter your searches by categories or other criteria (usually called faceting, such as those tag clouds or drill-downs). It features considerable function to develop powerful and specialized search applications.&lt;/p&gt;
&lt;p&gt;The challenge with many rich, expressive query languages, is how to generate these expressions reliability without a significant maintenance cost to the development team. Enter &lt;a href=&quot;https://github.com/mozilla/elasticutils&quot;&gt;ElasticUtils&lt;/a&gt;, which provides access to most of ElasticSearch&apos;s features, but using a chainable queryset-like expression API for generating search parameters.&lt;/p&gt;
&lt;p&gt;As a case, here&apos;s an actual (relatively simply) query generated from our search system looking for products related to &quot;nike air max&quot; (a line of shoes):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;filter&quot;: {
        &quot;term&quot;: {
            &quot;is_visible&quot;: true
        }
    },
    &quot;query&quot;: {
        &quot;query_string&quot;: {
            &quot;default_field&quot;: &quot;_all&quot;,
            &quot;query&quot;: &quot;nike air max&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This query, takes our user supplied input: &quot;nike air max&quot;, and generates a &lt;code&gt;query_string&lt;/code&gt; type query against the &lt;code&gt;_all&lt;/code&gt; field (which is a combination of all the indexed fields), and filters the results to ones that are marked public (&lt;code&gt;is_visible = true&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;As you can see, ElasticSearch queries are a highly nested JSON structure. Having to manage all these nodes and keep them in order can be complex and error prone.&lt;/p&gt;
&lt;p&gt;Contrast the same query using ElasticUtils:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from elasticutils import S

query = S().filter(is_visible=True).query(_all__query_string=&apos;nike air max&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice how we can construct the same nested structure, in a chainable fashion that allows us to augment or enhance our existing queries? What if we wanted to restrict our query just to products in our &lt;code&gt;shoes&lt;/code&gt; category?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;query = query.filter(category=&quot;shoes&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Django Integration&lt;/h1&gt;
&lt;p&gt;While &lt;a href=&quot;https://github.com/mozilla/elasticutils&quot;&gt;ElasticUtils&lt;/a&gt; is a general python library, it comes with some django integration out of the box to simplify integration. First, if you use the django-ized versions of the API constructs (&lt;code&gt;S&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, etc), they will leverage the django settings system for configuration like ElasticSearch server URLs.&lt;/p&gt;
&lt;p&gt;Second, ElasticUtils has pre-defined &lt;a href=&quot;http://www.celeryproject.org&quot;&gt;Celery&lt;/a&gt; tasks for indexing and un-indexing your django models. This Makes it really straightforward to hook up a &lt;code&gt;post_save&lt;/code&gt; signal handler to your models to have them re-indexed when updated in real-time (vs the traditional overnight batch re-index).&lt;/p&gt;
&lt;p&gt;The one missing out-of-the-box component for Django is a management command for indexing your data. There&apos;s an incomplete &lt;a href=&quot;https://github.com/mozilla/elasticutils/pull/168&quot;&gt;pull-request&lt;/a&gt; that&apos;s unfortunately been sidelined for now. Hopefully the team behind ElasticUtils can come together and finish it off. In the meantime, you can easily roll your own in less than 100 lines of code.&lt;/p&gt;
&lt;h1&gt;Indexing your Data&lt;/h1&gt;
&lt;h2&gt;Assembling your Mappings&lt;/h2&gt;
&lt;p&gt;To define your indexes in &lt;a href=&quot;https://github.com/mozilla/elasticutils&quot;&gt;ElasticUtils&lt;/a&gt;, you define a &lt;code&gt;MappingType&lt;/code&gt; class much like in the Django ORM, you&apos;d define a &lt;code&gt;Model&lt;/code&gt;. This allows you to provide the necessary parameters to ElasticSearch to define the properties of the index and provide helper methods to perform the indexing and construct the searches.&lt;/p&gt;
&lt;p&gt;The amount of boilerplate code required depends on whether you&apos;re using the base &lt;code&gt;MappingType&lt;/code&gt; or the django-ized version. The django version leverages the Django ORM for retrieval of documents to index as an example.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from elasticutils.contrib.django import Indexable, MappingType
from example.product.models import Product


class ProductMapping(MappingType, Indexable):
    @classmethod
    def get_index(cls):
        return &apos;products&apos;

    @classmethod
    def get_mapping_type_name(cls):
        return &quot;product&quot;

    @classmethod
    def get_model(cls):
        return Product

    @classmethod
    def get_mapping(cls):
        return {
            # TBD
        }

    @classmethod
    def extract_document(cls, obj_id, obj=None):
        return {
            # TBD
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There&apos;s a couple methods with TBDs (&lt;code&gt;extract_document()&lt;/code&gt;, &lt;code&gt;get_mapping()&lt;/code&gt;) in there that we&apos;ll revisit individually, but you can see much of this is scaffolding not unlike the &lt;code&gt;Meta&lt;/code&gt; class on Django models (but using classmethods rather than a nested inner class). These configuration methods for the most part just convert their output to JSON and are delivered to ElasticSearch un-modified.&lt;/p&gt;
&lt;h2&gt;Defining your Data Mapping&lt;/h2&gt;
&lt;p&gt;The mapping configuration ultimately defines how ElasticSearch stores and indexes your data. It needs to know what fields are available in a given index, and parameters on how to consume and process those fields. If you&apos;ve ever used &lt;a href=&quot;http://lucene.apache.org/solr/&quot;&gt;Apache SOLR&lt;/a&gt;, you&apos;ll be relieved how much easier this configuration is compared to the XML-hell that you&apos;ve surely experienced.&lt;/p&gt;
&lt;p&gt;For our example Product index, let&apos;s create some common fields that might be associated with a product listing. This isn&apos;t designed to be a full tutorial on elasticsearch, so we&apos;ll have to skip over some of the more complex configuration options around analyzers, tokenizers and other indexing controls.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@classmethod
def get_mapping(cls):
    return {
        &apos;properties&apos;: {
            &apos;name&apos;: {
                &apos;type&apos;: &apos;string&apos;,
            },
            &apos;description&apos;: {
                &apos;type&apos;: &apos;string&apos;,
                &apos;analyzer&apos;: &apos;snowball&apos;,
            },
            &apos;sku&apos;: {
                &apos;type&apos;: &apos;string&apos;,
                &apos;index&apos;: &apos;not_analyzed&apos;,
            },
            &apos;price&apos;: {
                &apos;type&apos;: &apos;integer&apos;,
                &apos;index&apos;: &apos;not_analyzed&apos;,
            },
            &apos;category&apos;: {
                &apos;type&apos;: &apos;string&apos;,
                &apos;index&apos;: &apos;not_analyzed&apos;,
            },
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Most of our fields are designated as type &lt;code&gt;string&lt;/code&gt;, while our &lt;em&gt;price&lt;/em&gt; field is an integer (it will be number of cents, so &lt;code&gt;price_in_dollars * 100&lt;/code&gt;). You&apos;ll notice that many of the fields have an attribute &lt;code&gt;analyzer: not_analyzed&lt;/code&gt;. This is an instruction to ElasticSearch not to attempt to parse the field and just leave it as is. Normally, ElasticSearch would split the field into terms based on word boundaries (see the &lt;a href=&quot;http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html&quot;&gt;standard analyzer&lt;/a&gt; which is the default). But for many of the fields, we want to it to be indexed and stored exactly as we delivered (such as for &lt;em&gt;sku&lt;/em&gt; which should be treated as a single term). For &lt;em&gt;description&lt;/em&gt;, we&apos;ve used the &lt;a href=&quot;http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/analysis-snowball-analyzer.html&quot;&gt;snowball analyzer&lt;/a&gt; which provides additional filtering around stop words and stemming. You can also create your own analyzers for more custom indexing of a given field.&lt;/p&gt;
&lt;p&gt;This is just the tip of the iceberg. There&apos;s a multitude of configuration parameters for each field in your mapping.&lt;/p&gt;
&lt;h2&gt;Extracting Fields during Indexing&lt;/h2&gt;
&lt;p&gt;After defining the index mapping fields, let&apos;s implement the other un-implemented method, &lt;code&gt;extract_document()&lt;/code&gt;, that captures and prepares your data into the relevant fields. This provides you the control in extracting and transforming your data prior to ingestion by elasticsearch.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    @classmethod
    def extract_document(cls, obj_id, obj=None):
        if obj is None:
            obj = cls.get_model().get(pk=obj_id)

        return {
            &apos;id&apos;: obj.pk,
            &apos;name&apos;: obj.name,
            &apos;description&apos;: obj.description,
            &apos;sku&apos;: obj.sku,
            &apos;price&apos;: int(obj.price * 100),  # Convert to cents
            &apos;category&apos;: obj.category.name.lower(),   # assuming `category` is a foreign key
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we&apos;ve extracted several attributes on our model as well the product category from a related model.&lt;/p&gt;
&lt;h2&gt;Create Indexes&lt;/h2&gt;
&lt;p&gt;Finally, With all your mappings configured, you can now create or update your indexes using elasticsearch. We simply generate a settings configuration based on the elasticsearch options and elasticutils does the work for us.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;es = ProductMapping.get_es()
settings = {}

# Add our mapping configuration to the index settings
settings.update(ProductMapping.get_mapping())

# TBD: Add index settings here such as custom analyzers

es.create_index(ProductMapping.get_index(), settings=settings)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, let&apos;s leverage the built-in celery tasks to perform the index on our model data. To index a model, you simply provide its primary key to the &lt;code&gt;index_objects&lt;/code&gt; task, which as we&apos;ve defined above in &lt;code&gt;extract_document()&lt;/code&gt;, will pull it from the database and extract the fields for indexing.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from elasticutils.contrib.django import tasks


model_objs = ProductMapping.get_model().objects.all()
model_ids = list(model_objs.values_list(&apos;pk&apos;, flat=True))
tasks.index_objects(ProductMapping, model_ids)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Searching your Index&lt;/h1&gt;
&lt;p&gt;Now that we&apos;ve indexed our data, let&apos;s walk through a couple example searches that can demonstration the richness of the ElasticSearch and ElasticUtils query expression API.&lt;/p&gt;
&lt;p&gt;Couple of notes on the ElasticUtils &lt;code&gt;S&lt;/code&gt; class that handles your search queries. They mimic many of the attributes of Django&apos;s querysets.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;They&apos;re chainable, so you can build up your search parameters through successive calls to add filters, queries and other parameters. Likewise, you can build-up common base search parameters and re-use it for a number of sub-queries that share those common parameters.&lt;/li&gt;
&lt;li&gt;They&apos;re lazy, so search is only performed when you try to act on the data such as iterating, or calling specific methods like &lt;code&gt;count()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Search for Matching Terms&lt;/h2&gt;
&lt;p&gt;Let&apos;s start with the obvious use case, we want to find all products who&apos;s name contains the key search terms. With &lt;a href=&quot;http://lucene.apache.org&quot;&gt;Lucene&lt;/a&gt; based indexes, you usually can choose between a rich user supplied query language like a google search or constructing your search parameters more programatically (or a combination of both). If you&apos;re looking to give your users a free-form input (again, like Google) to specify their search parameters with operators and other modifiers (for example: &lt;code&gt;nike AND &quot;air max&quot; or category:shoes&lt;/code&gt;), you&apos;re like going to want to use ElasticSearch&apos;s &lt;a href=&quot;http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html&quot;&gt;query string query&lt;/a&gt;. On the other hand, if your interface is more data oriented (say a bunch of checkboxes and sliders for controlling the search parameters), you&apos;ll want more exact search controls, you&apos;ll want to leverage ElasticSearch&apos;s &lt;a href=&quot;http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-queries.html&quot;&gt;many other queries&lt;/a&gt; including &lt;code&gt;match&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; queries.&lt;/p&gt;
&lt;p&gt;ElasticUtils takes a cue from django&apos;s querysets and allows you to specify the type of query using a double underscore qualifier. So you can search a given field using a type of query like: &lt;code&gt;[field_name]__[query_type]&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s = ProductMapping.search()
results = s.query(name__query_string=&apos;nike &quot;air max&quot; or category:shoes&apos;)
for result in results:
    # process the results
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If instead of a free-form query string, we could instead build up a search programmatically using another query type. ElasticSearch provides a &lt;a href=&quot;http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html&quot;&gt;prefix query&lt;/a&gt; that can provide a good way to autocomplete search terms that begin with the inputted search phrase. They&apos;re are more efficient methods using ngrams, but this will suffice for our example.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s = ProductMapping.search()
# Returns all results that start with &apos;nik&apos; in the `shoes` category
results = s.query(name__prefix=&apos;nik&apos;).filter(category=&apos;shoes&apos;)
for result in results:
    # process the results
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Faceted Search Results&lt;/h2&gt;
&lt;p&gt;One of the powerful features of ElasticSearch is the ability to quickly generate facets based on your indexed fields. If you&apos;re unfamiliar with facets, think of a tag cloud, or a list of categories (such as brands on an e-commerce site) that allow you to drill-down through a list of results to find your intended document.&lt;/p&gt;
&lt;p&gt;In our example mapping, we have a &lt;em&gt;category&lt;/em&gt; field that would be a nice facet to help our users select which category they&apos;re looking for within our search results. Let&apos;s first search for &quot;nike&quot; and then display a list of categories that have matches for that product name.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s = ProductMapping.search()
# Add facet results for `category`
query = s.query(name=&apos;nike&apos;).facet(&apos;category&apos;)
facets = query.facet_counts()
# Let&apos;s iterate the category facets
for facet in facets[&apos;category&apos;]:
    category = facet[&apos;term&apos;]
    count = facet[&apos;count&apos;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Counts&lt;/h2&gt;
&lt;p&gt;Sometimes, you don&apos;t necessarily need to retrieve the search results, but just want to display the number of results. Like the Django ORM, you can call &lt;code&gt;.count()&lt;/code&gt; to retrieve the number of results for a given query.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s = ProductMapping.search()
# Returns all results that start with &apos;nik&apos; in the `shoes` category
num_results = s.query(name__prefix=&apos;nik&apos;).filter(category=&apos;shoes&apos;).count()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, this is just a sampler. There are numerous ways to search in elasticsearch and these are but a few simple examples. As your queries grow in complexity, the chain-ability of ElasticUtils search API keeps everything manageable.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;There you have it, a method to build complex search systems using the powerful &lt;a href=&quot;http://www.elasticsearch.org&quot;&gt;ElasticSearch&lt;/a&gt; systsem in a very pythonic manner. If you&apos;re familiar with the common Django ORM patterns, it&apos;s even better.&lt;/p&gt;
&lt;p&gt;Hopefully this gives you an overview of the &lt;a href=&quot;https://github.com/mozilla/elasticutils&quot;&gt;ElasticUtils&lt;/a&gt; python library as a powerful interface to the ElasticSearch indexing and retrieval system. Much like the Django ORM makes working with databases easier compared with raw SQL, ElasticUtils makes performing complex search queries easier than building your own ElasticSearch ReST calls.&lt;/p&gt;
&lt;p&gt;This was really just an introduction, we only showed simple field extraction and text searching. Much of the power of elasticsearch is realized when you start implementing more complex patterns like faceting, range queries, autocomplete, spell correction and suggestions. If there&apos;s interest (leave me a comment), I&apos;ll work on follow-up posts on how to construct those patterns on top of ElasticUtils.&lt;/p&gt;
&lt;h2&gt;Caveats&lt;/h2&gt;
&lt;p&gt;I wrote this guide based on ElasticUtils v0.80. The development trunk recently ported from the underlying &lt;a href=&quot;https://github.com/rhec/pyelasticsearch&quot;&gt;pyelasticsearch&lt;/a&gt; library, to the officially blessed, &lt;a href=&quot;https://github.com/elasticsearch/elasticsearch-py&quot;&gt;elasticsearch-py&lt;/a&gt; python bindings. While ElasticUtils for the most part masks the need to understand the underlying library, esoteric or management commands may require direct library access.&lt;/p&gt;
</content:encoded></item></channel></rss>